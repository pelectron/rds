# TODO: add tagging/grouping and group descriptions
name = "MAX17320"
version = 1
register_width = 16  # the register width in bits (defualts to 32)
word_width = 16
license = "bla"
description = "a description of the chip"
num_pages = 32  # the number of memory pages (defaults to 1)
registers_per_page = 16  # number of registers per page (defaults to 1)
endian = "little"

[Registers]
base_addr = 0
size = 512

[Registers.defaults]
# required register data
addr = "undefined"
initial = 0x0000  # the initial/reset value
zeros_mask = 0  # a mask which describes which bits need to be kept 0
ones_mask = 0  # a mask which describes which bits need to be 1
x_mask = 0  # a mask which describes don't care bits
backup = "none"
signed = false
access = "r"
size = 1
# custom data
i2c_addr = 0x6C

[Registers.Status]
addr = 0x000
type = "special"
initial = 0x0002
x_mask = 0x839
description = "The Status register maintains all flags related to alert thresholds and battery insertion or removal."

[Registers.Status.PA]
position = 15
name = "Protection Alert"
description = "This bit is set to a 1 when there is a protection event. The details of which protection event can be found in the ProtAlrts register. This bit must be cleared by system software to detect the next protection event. However, prior to clearing this bit, the ProtAlrts register must first be written to 0x0000."

[Registers.Status.Smx]
position = 14
name = "Maximum SOC Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever SOC rises above the maximum SAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.SS andMiscCFG.SACFG bit descriptions."

[Registers.Status.Tmx]
position = 13
name = "Maximum Temperature Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a Temperature register reading is above the maximum TAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.TS bit description."

[Registers.Status.Vmx]
position = 12
name = "Maximum Voltage Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a VCell register reading is above the maximum VAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.VS bit description."

[Registers.Status.Smn]
position = 10
name = "Minimum SOC Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever SOC falls below the minimum SAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.SS and MiscCFG.SACFG bit descriptions."

[Registers.Status.Tmn]
position = 9
name = "Minimum Temperature Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a Temperature register reading is below the minimum TAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.TS bit description."

[Registers.Status.Vmn]
position = 8
name = "Minimum Voltage Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a VCell register reading is below the minimum VAlrtTh value. This bit may or may not need to be cleared by system software to detect the next event. See Config.VS bit description."

[Registers.Status.dSOCi]
position = 7
name = "State-of-Charge 1% Change Alert"
description = "This is set to 1 whenever the RepSOC register crosses an integer percentage boundary such as 50.0%, 51.0%, etc. Must be cleared by host software."

[Registers.Status.Imx]
position = 6
name = "Maximum Current Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a Current register reading is above the maximum IAlrtTh value. This bit is cleared automatically when Current falls below maximum IAlrtTh value."

[Registers.Status.Imn]
position = 2
name = "Minimum Current Alert Threshold Exceeded"
description = "This bit is set to a 1 whenever a Current register reading is below the minimum IAlrtTh value. This bit is cleared automatically when Current rises above minimum IAlrtTh value."

[Registers.Status.POR]
position = 1
name = "Power-On Reset"
description = "This bit is set to a 1 when the device detects that a software or hardware POR event has occurred. This bit must be cleared by system software to detect the next POR event."

[Registers.VAlrtTh]
addr = 0x001
initial = 0x00FF
description = "The nVAlrtTh register shown in Table 86 sets upper and lower limits that generate an ALRT pin interrupt if exceeded by any of the cell voltage readings. The upper 8 bits set the maximum value and the lower 8 bits set the minimum value. Interrupt threshold limits are selectable with 20mV resolution over the full operating range of the VCell register. At powerup, the thresholds default to their maximum settings unless they are configured to be restored from nonvolatile memory instead by setting the nNVCfg1.enAT bit."

[Registers.VAlrtTh.VMAX]
name = "Maximum voltage reading"
description = "An alert is generated if the maximum cell voltage reading exceeds this value. This field has 20mV LSb resolution."
msb = 15
lsb = 8
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.02  # step value in volts (value = min + step*field_value)

[Registers.VAlrtTh.VMIN]
name = "Minimum voltage reading"
description = "An alert is generated if the VCell register reading falls below this value. This field has 20mV LSb resolution."
msb = 7
lsb = 0
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.02  # step value in volts (value = min + step*field_value)

[Registers.TAlrtTh]
addr = 0x002
initial = 0x7F80
type = "special"
description = "The nTAlrtTh register sets upper and lower limits that generate an ALRT pin interrupt if exceeded by any thermistor reading. The upper 8 bits set the maximum value and the lower 8 bits set the minimum value. Interrupt threshold limits are stored in 2’s-complement format with 1ºC resolution over the full operating range of the Temp register. At power-up, the thresholds default to their maximum settings unless they are configured to be restored from nonvolatile memory instead by setting the nNVCfg1.enAT bit."

[Registers.TAlrtTh.TMAX]
name = "Maximum temperature reading"
description = "An alert is generated if any temperature channel reading exceeds this value. This field is signed 2's complement format with 1ºC LSb resolution."
signed = true
msb = 15
lsb = 8
unit = "°C"

[Registers.TAlrtTh.TMIN]
name = "Minimum temperature reading"
description = "An alert is generated if the Temp register reading falls below this value. This field is signed 2's complement format with 1ºC LSb resolution."
signed = true
msb = 7
lsb = 0
unit = "°C"

[Registers.SAlrtTh]
addr = 0x003
initial = 0xFF00
type = "special"
description = "The nSAlrtTh register shown in Table 88 sets upper and lower limits that generate an ALRT pin interrupt if exceeded by the selected RepSOC, AvSOC, MixSOC, or VFSOC register values. See the MiscCFG.SACFG setting for details. The upper 8 bits set the maximum value and the lower 8 bits set the minimum value. Interrupt threshold limits are selectable with 1% resolution over the full operating range of the selected SOC register. At power-up, the thresholds default to their maximum settings unless they are configured to be restored from nonvolatile memory instead by setting the nNVCfg1.enAT bit."

[Registers.SAlrtTh.SMAX]
name = "Maximum state-of-charge reading"
description = "An alert is generated if the selected SOC register reading exceeds this value. This field has 1% LSb resolution."
msb = 15
lsb = 8
unit = "%"

[Registers.SAlrtTh.SMIN]
name = "Minimum state-of-charge reading"
description = "An alert is generated if the selected SOC register reading falls below this value. This field has 1% LSb resolution."
msb = 7
lsb = 0
unit = "%"

[Registers.AtRate]
addr = 0x004
unit = "μV"
step = 1.5625
signed = true
description = "Host software should write the AtRate register with a negative two’s-complement 16-bit value of a theoretical load current prior to reading any of the at-rate output registers."

[Registers.RepCap]
addr = 0x005
description = "RepCap or Reported Capacity is a filtered version of the AvCap register that prevents large jumps in the reported value caused by changes in the application such as abrupt changes in temperature or load current. See the Fuel-Gauge Empty Compensation section f"
unit = "µVh"

[Registers.RepSOC]
addr = 0x006
description = "RepSOC is a filtered version of the AvSOC register that prevents large jumps in the reported value caused by changes in the application such as abrupt changes in load current. RepSOC corresponds to RepCap and FullCapRep. RepSOC is intended to be the final state-of-charge percentage output for use by the application. See the Fuel-Gauge Empty Compensation section for details."
unit = "%"

[Registers.Age]
addr = 0x007
description = "The Age register contains a calculated percentage value of the application’s present cell capacity compared to its expected capacity. The result can be used by the host to gauge the battery pack health as compared to a new pack of the same type. The equation for the register output is: Age Register = 100% x (FullCapNom Register/DesignCap Register)"
unit = "%"

[Registers.MaxMinVolt]
addr = 0x008
type = "special"
initial = 0x00FF
backup = "Saves to nMaxMinVolt (1ACh) if nNVCfg2.enMMV is set (does not restore from nonvolatile)."
description = "The MaxMinVolt register maintains the maximum and minimum of all cell voltage readings since device reset. Each time the voltage registers update, they are compared against these values. If a new voltage channel reading is larger than the maximum or less than the minimum, the corresponding value is replaced with the new reading. At power-up, the maximum voltage value is set to 00h (the minimum) and the minimum voltage value is set to FFh (the maximum). Therefore, both values are updated after the first update. Host software can reset this register by writing it to its power-up value of 0x00FF. The maximum and minimum voltages are each stored as 8-bit values with a 20mV resolution. MaxMinVolt is not cumulative across the entire battery lifetime. After each periodic nonvolatile-memory save, MaxMinVolt resets to 0x00FF to find the next max/min volt across the next segment of battery life. This behavior helps provide a useful log across the battery lifetime where each log segment shows the maximum and minimum voltage experienced across only that segment."

[Registers.MaxMinVolt.MaxVCELL]
description = "Maximum channel voltage reading (20mV resolution)"
msb = 15
lsb = 8
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.02  # step value in volts (value = min + step*field_value)

[Registers.MaxMinVolt.MinVCELL]
description = "Minimum channel voltage reading (20mV resolution)"
msb = 7
lsb = 0
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.02  # step value in volts (value = min + step*field_value)

[Registers.MaxMinTemp]
addr = 0x009
type = "special"
initial = 0x807
backup = "Periodically saves to nMaxMinTemp (1ADh) if nNVCfg2.enMMT is set, but does not restore from nonvolatile memory."
description = "The MaxMinTemp register maintains the maximum and minimum Temp register (01Bh) values since the last fuel-gauge reset or until cleared by host software. Each time the Temp register updates, it is compared against these values. If the reading is larger than the maximum or less than the minimum, the corresponding values are replaced with the new reading. At power-up, the maximum value is set to 80h (minimum) and the minimum value is set to 7Fh (maximum). Therefore, both values are changed to the Temp register reading after the first update. Host software can reset this register by writing it to its power-up value of 807Fh. The maximum and minimum temperatures are each stored as two’s complement 8-bit values with 1°C resolution. MaxMinTemp is not cumulative across the entire battery lifetime. After each periodic nonvolatile memory save, MaxMinTemp resets to 807Fh to find the next maximum and minimum temperatures across the next segment of battery life. This behavior helps provide a useful log across the battery lifetime where each log segment shows the maximum and minimum temperature experienced across only that segment."

[Registers.MaxMinTemp.MaxTemperature]
signed = true
description = "Maximum Temp register reading (1ºC resolution) "
msb = 15
lsb = 8
unit = "°C"

[Registers.MaxMinTemp.MinTemperature]
signed = true
description = "Minimum Temp register reading (1ºC resolution) "
msb = 7
lsb = 0
unit = "°C"

[Registers.MaxMinCurr]
addr = 0x00A
type = "special"
initial = 0x807F
backup = "Periodically saves to nMaxMinCurr (1ABh) if nNVCfg2.enMMC is set, but does not restore from nonvolatile memory."
description = "The MaxMinCurr register maintains the maximum and minimum Current register values since the last IC reset or until cleared by host software. Each time the Current register updates, it is compared against these values. If the reading is larger than the maximum or less than the minimum, the corresponding value is replaced with the new reading. At powerup, the maximum current value is set to 80h (the minimum) and the minimum current value is set to 7Fh (the maximum). Therefore, both values are changed to the Current register reading after the first update. Host software can reset this register by writing it to its power-up value of 0x807F. The maximum and minimum voltages are each stored as two’s complement 8-bit values with 0.4mV/RSENSE resolution. Table 54 shows the register format. MaxMinCurr is not cumulative across the entire battery lifetime. After each periodic nonvolatile-memory save, MaxMinCurr resets to 0x807F to find the next maximum and minimum current across the next segment of battery life. This behavior helps provide a useful log across the battery lifetime where each log segment shows the maximum and minimum current experienced across only that segment."

[Registers.MaxMinCurr.MaxCurrent]
signed = true
msb = 15
lsb = 8
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.04  # step value in volts (value = min + step*field_value)

[Registers.MaxMinCurr.MinCurrent]
signed = true
msb = 7
lsb = 0
unit = "V"
zero_code_value = 0  # zero code value in volts
step = 0.04  # step value in volts (value = min + step*field_value)

[Registers.Config]
addr = 0x00B
type = "special"
initial = 0x2290
zeros_mask = 0x8102

[Registers.Config.SS]
position = 14
name = "SOC ALRT Sticky"
description = "When SS = 1, SOC alerts can only be cleared through software. When SS = 0, SOC alerts are cleared automatically when the threshold is no longer exceeded."

[Registers.Config.TS]
position = 13
name = "Temperature ALRT Sticky"
description = "When TS = 1, temperature alerts can only be cleared through software. When TS = 0, temperature alerts are cleared automatically when the threshold is no longer exceeded."

[Registers.Config.VS]
position = 12
name = "Voltage ALRT Sticky"
description = "When VS = 1, voltage alerts can only be cleared through software. When VS = 0, voltage alerts are cleared automatically when the threshold is no longer exceeded."

[Registers.Config.DisLDO]
position = 11
name = "Disable AOLDO"
description = "Set DisLDO to 1 to disable the Always-On LDO if it is enabled in nPackCfg.AOCfg."

[Registers.Config.PBEn]
position = 10
name = "Pushbutton Enable"
description = "Set PBEn = 1 to enable wakeup by pushbutton. This application allows a product to be completely sealed with battery disconnected until a shared system button is pressed."

[Registers.Config.DisBlockRead]
position = 9
name = "Disable SBS Block Read"
description = "Set DisBlockRead to 1 for normal read access in the 16h memory space. Clear DisBlockRead to 0 to enable SBS block reads when SBS Mode is enabled with nNVCfg0.SBSen. The default setting for DisBlockRead is 1."

[Registers.Config.SHIP]
position = 7
name = "Ship or Deepship Command"
description = "Write this bit to logic 1 to force into ship or deepship mode based on nProtCfg.DeepShpEn. Both FETs open within 1.4s and the IC will fully enter ship or deepship after timeout of the Shutdown Timer register which is configured in nDelayCfg.UVPTimer. SHIP is reset to 0 at power-up and upon exiting ship or deepship mode."

[Registers.Config.COMMSH]
position = 6
name = "Communication Shutdown"
description = "Set to logic 1 to force the device to enter shutdown mode if both SDA and SCL are held low (I2C version) or DQ is held low (1-Wire version) for more than the timeout of the ShdnTimer register. This also configures the device to wake up on a rising edge of any communication. Note that if COMMSH is set to 0, the device wakes up an edge of any of the SDA/DQ or SCL/OD pins. See the Modes of Operation section."

[Registers.Config.ETHRM]
position = 4
name = "Enable Thermistor"
description = "Set to logic 1 to enable the automatic TH output bias and TH measurement."

[Registers.Config.FTHRM]
position = 3
name = "Force Thermistor Bias Switch"
description = "This allows the host to control the bias of the thermistor switch or enable fast detection of battery removal. Set FTHRM = 1 to always enable the thermistor bias switch. With a standard 10kΩ thermistor, this adds an additional 200μA, approximately, to the current drain of the circuit."

[Registers.Config.Aen]
position = 2
name = "Enable Alert on Fuel-Gauge Outputs"
description = "When Aen = 1, violation of any of the alert threshold register values by temperature, voltage, or SOC triggers an alert. This bit affects the ALRT pin operation only. The Smx, Smn, Tmx, Tmn, Vmx, Vmn, Imx, and Imn bits of the Status register (000h) are not disabled. Note that if this bit is set to 1, the ALSH bit should be set to 0 to prevent an alert condition from causing the device to enter shutdown mode."

[Registers.Config.PAen]
position = 0
name = "Protection Alert Enable"
description = "Set PAen = 1 to enable this feature that saves the protector faults (TooHotC, TooColdC, OVP, OCCP, DieHot, TooHotD, UVP, ODCP, LDet) into the low byte of the nBattStatus register. After each life logging write to NVM, the low byte of nBattStatus is cleared."

[Registers.QResidual]
addr = 0x00C
unit = "µVh"
description = "The QResidual register displays the calculated amount of charge in mAh that is presently inside of, but cannot be removed from the cell under present application conditions. This value is subtracted from the MixCap value to determine the capacity available to the user under present conditions (AvCap)."

[Registers.MixSOC]
addr = 0x00D
unit = "%"
description = "The MixSOC register holds the calculated present state-of-charge of the cell before any empty compensation adjustments are performed. MixSOC corresponds with MixCap and FullCapNom. See the Fuel-Gauge Empty Compensation section for d."

[Registers.AvSOC]
addr = 0x00E
unit = "%"
description = "The AvSOC register holds the calculated available state of charge of the cell based on all inputs from the ModelGauge m5 algorithm including empty compensation. The AvSOC percentage corresponds with AvCap and FullCapNom. The AvSOC register value is an unfiltered calculation. Jumps in the reported value can be caused by changes in the application such as abrupt changes in load current or temperature. See the Fuel-Gauge Empty Compensation section for details."
zero_code_value = 2

[Registers.MiscCfg]
addr = 0x00F
type = "special"
initial = 0x3070
zeros_mask = 0x0C0C
ones_mask = 0x0010
description = "The nMiscCfg control register enables various other functions of the device. The nMiscCfg register default values should not be changed unless specifically required by the application. Table 75 shows the register format."

[Registers.MiscCfg.FUS]
name = "Full Update Slope"
msb = 15
lsb = 12
description = "This field prevents jumps in the RepSOC and FullCapRep registers by setting the rate of adjustment of FullCapRep near the end of a charge cycle. The update slope adjustment range is from 2% per 15 minutes (0000b) to a maximum of 32% per 15 minutes (1111b)"
unit = "%/min"
zero_code_value = 2
step = 2

[Registers.MiscCfg.MR]
name = "Mixing Rate"
msb = 9
lsb = 5
description = "This value sets the strength of the servo mixing rate after the final mixing state has been reached (> 2.08 complete cycles). The units are MR0 = 6.25μV, giving a range up to 19.375mA with a standard 0.010Ω sense resistor. Setting this value to 00000b disables servo mixing and the IC continues with time-constant mixing indefinitely. The default setting is 18.75μV or 1.875mA with a standard sense resistor."
unit = "uV"
step = 6.25

[Registers.MiscCfg.SACFG]
name = "SOC Alert Config"
msb = 1
lsb = 0
description = "SOC Alerts can be generated by monitoring any of the SOC registers as follows. SACFG defaults to 00 at power-up."

[Registers.MiscCfg.SACFG.values]
0 = "SOC Alerts are generated based on the RepSOC register."
1 = "SOC Alerts are generated based on the AvSOC register."
2 = "SOC Alerts are generated based on the MixSOC register."
3 = "SOC Alerts are generated based on the VFSOC register."

[Registers.FullCapRep]
addr = 0x010
description = "This register reports the full capacity that goes with RepCap, generally used for reporting to the user. A new full-capacity value is calculated at the end of every charge cycle in the application. "
unit = "µVh"

[Registers.TTE]
addr = 0x011
name = "time to empty"
unit = "s"
# (102.3*60*60)/65536 seconds/bit
step = 5.6195068359375
description = "The TTE register holds the estimated time-to-empty for the application under present temperature and load conditions. The TTE value is determined by dividing the AvCap register by the AvgCurrent register. The corresponding AvgCurrent filtering gives a delay in TTE empty, but provides more stable results. The TTE register has a maximum value of 102.3 hours. When TTE is larger than the maximum value, the TTE register saturates and contains the maximum value (FFFFh). The host can calculate times longer than the maximum value with the following equation: TTECALCULATED (hours) = AvCap(mAh)/AvgCurrent(mA)"

[Registers.QRTable00]
addr = 0x012
description = "The nQRTable00 to nQRTable30 register locations contain characterization information regarding cell capacity that is not available under certain application conditions."
initial = 0x1050

[Registers.FullSOCThr]
addr = 0x013
ones_mask = 0b101
zeros_mask = 0b10
description = "The nFullSOCThr register gates detection of end-of-charge. VFSOC must be larger than the nFullSOCThr value before nIChgTerm is compared to the AvgCurrent register value. The recommended nFullSOCThr register setting for most custom characterized applications is 95% . For EZ performance applications, the recommendation is 80% (5005h). See the nIChgTerm register description and End-of-Charge Detection section for details."
msb = 15
lsb = 3
unit = "%"

[Registers.RCell]
addr = 0x014
type = "special"
initial = 0x0290
unit = " Ω"
step = 0.000244140625
description = "The RCell register displays the calculated internal resistance of the cell or the average internal resistance of each cell in the cell stack. RCell is determined by comparing open-circuit voltage (VFOCV) against measured voltage (VCell) over a long time period while under load current."

[Registers.AvgTA]
addr = 0x016
unit = "temperature"
description = "The AvgTA register reports an average of the readings from the Temp register. The averaging period is configurable from 6 minutes up to 12 hours as set by the FilterCfg register. The first Temp register reading after returning to active mode sets the starting point of the averaging filters."

[Registers.Cycles]
addr = 0x017
backup = "nCycles"
type = "special"
description = "The Cycles register maintains a total count of the number of charge/discharge cycles of the cell that have occurred. The result is stored as a percentage of a full cycle. For example, a full charge/discharge cycle results in the Cycles register incrementing by 100%. The Cycles register has a full range of 0 to 16383 cycles with a 25.0% LSb. Cycles is periodically saved to nCycles to provide a long term nonvolatile cycle count."
unit = "%"
step = 25

[Registers.DesignCap]
addr = 0x018
unit = "µVh"
description = "The nDesignCap register holds the expected capacity of the cell. This value is used to determine age and health of the cell by comparing against the measured present cell capacity."

[Registers.AvgVCell]
addr = 0x019
description = "The AvgVCell register reports an average of the VCell register readings. The time period for averaging is configurable from a 12 second to 24 minute time period. See the nFilterCfg register description for details on setting the time filter. The first VCell register reading after power-up or exiting shutdown mode sets the starting point of the AvgVCell register. Note that when a cell relaxation event is detected the averaging period changes to the period defined by the RelaxCfg.dt setting. The register reverts back to its normal averaging period when a charge or discharge current is detected."
unit = "mV"
step = 0.078125

[Registers.VCell]
addr = 0x01A
description = """Each update cycle the lowest reading from all cell voltage measurements is placed in the VCell register. VCell is used as the voltage input to the fuel gauge algorithm."""
unit = "mV"
step = 0.078125

[Registers.Temp]
addr = 0x01B
unit = "°C"
step = 0.00390625
signed = true
description = "The Temp register is the input to the fuel gauge algorithm. The Temp register reflects the highest thermistor temperature if enabled, and the die-temperature if the thermistors are disabled."

[Registers.Current]
addr = 0x01C
description = """ The IC measures the voltage between the CSP and CSN pins and the result is stored as a two’s complement value in the Current register. Voltages outside the minimum and maximum register values are reported as the minimum or maximum value. The register value should be divided by the sense resistance to convert to amps. The value of the sense resistor determines the resolution and the full-scale range of the current readings. Table 53 shows range and resolution values for typical sense resistances."""
unit = "μV"
step = 1.5625

[Registers.AvgCurrent]
addr = 0x01D
description = """ The AvgCurrent register reports an average of Current register readings over a configurable 0.7 second to 6.4 hour time period. See the nFilterCfg register description for details on setting the time filter. The first Current register reading after returning to active mode sets the starting point of the AvgCurrent filter."""
unit = "μV"
step = 1.5625

[Registers.IChgTerm]
addr = 0x01E
unit = "μV"
step = 1.5625
description = """The nIChgTerm register allows the device to detect when a charge cycle of the cell has completed. nIChgTerm should be programmed to the exact charge termination current used in the application. The device detects end-of-charge if all the following conditions are met: 
- VFSOC Register > FullSOCThr Register
- AND IChgTerm x 0.125 < Current Register < IChgTerm x 1.25
- AND IChgTerm x 0.125 < AvgCurrent Register < IChgTerm x 1.25
See the End-of-Charge Detection section for more details. 
"""

[Registers.AvCap]
addr = 0x01F
unit = "µVh"
description = "The AvCap register holds the calculated available capacity of the cell pack based on all inputs from the ModelGauge m5 algorithm including empty compensation. The register value is an unfiltered calculation. Jumps in the reported value can be caused by changes in the application such as abrupt changes in load current or temperature. See the Fuel-Gauge Empty Compensation."

[Registers.TTF]
addr = 0x020
unit = "s"
step = 5.625
description = "The TTF register holds the estimated time-to-full for the application under present conditions. The TTF value is determined by learning the constant current and constant voltage portions of the charge cycle based on experience of prior charge cycles. Time-to-full is then estimated by comparing the present charge current to the charge termination current. Operation of the TTF register assumes all charge profiles are consistent in the application. See the nTTFCfg for configuration and the Typical Operating Characteristics for sample performance."

[Registers.DevName]
addr = 0x021
description = "The DevName register holds device type and firmware revision information. This allows the host software to easily identify the type of IC being communicated to. The DevName for the IC is 4209h, 420Ah, or 420Bh."
type = "special"

[Registers.DevName.Revision]
msb = 15
lsb = 4

[Registers.DevName.Device]
msb = 3
lsb = 0

[Registers.QRTable10]
addr = 0x022
initial = 0x8002
derived_from = "QRTable00"

[Registers.FullCapNom]
addr = 0x023
description = "This register holds the calculated full capacity of the cell, not including temperature and empty compensation. A new fullcapacity nominal value is calculated each time a cell relaxation event is detected. This register is used to calculate other outputs of the ModelGauge m5 algorithm."
unit = "µVh"

[Registers.ChargingCurrent]
addr = 0x028
unit = "μV"
step = 1.5625
description = "The ChargingCurrent register reports the prescribed charging current. See the Charging Prescription section for more details."

[Registers.FilterCfg]
addr = 0x029
initial = 0x0EA4
zeros_mask = 0xC000
description = "The nFilterCfg register sets the averaging time period for all ADC readings, for mixing OCV results, and coulomb count results. It is recommended that these values are not changed unless absolutely required by the application."

[Registers.FilterCfg.TEMP]
description = "Sets the time constant for the AvgTA register. The default POR value of 0001b gives a time constant of 1.5 minutes. The equation setting the period is: AvgTA time constant = 45s x 2^TEMP"
msb = 13
lsb = 11

[Registers.FilterCfg.MIX]
description = "Sets the time constant for the mixing algorithm. The default POR value of 1101b gives a time constant of 12.8 hours. The equation setting the period is: Mixing Period = 45s x 2^(MIX-3)"
msb = 10
lsb = 7

[Registers.FilterCfg.VOLT]
description = "Sets the time constant for the AvgVCell register. The default POR value of 010b gives a time constant of 45.0s. The equation setting the period is: AvgVCell time constant = 45s x 2^(VOLT-2)"
msb = 6
lsb = 4

[Registers.FilterCfg.CURR]
description = "Sets the time constant for the AvgCurrent register. The default POR value of 0100b gives a time constant of 5.625s. The equation setting the period is: AvgCurrent time constant = 45s x 2(CURR-7)"
msb = 3
lsb = 0

[Registers.ChargingVoltage]
addr = 0x02A
unit = "mV"
step = 0.078125
description = "The ChargingVoltage register reports the prescribed charging voltage."

[Registers.MixCap]
addr = 0x02B
unit = "µVh"
description = "The MixCap register holds the calculated remaining capacity of the cell before any empty compensation adjustments are performed."

[Registers.QRTable20]
addr = 0x032
derived_from = "QRTable00"
initial = 0x078C

[Registers.DieTemp]
addr = 0x034
unit = "°C"
step = 0.00390625
signed = true
description = "This register displays temperature in degrees Celsius, ±128°C or 1°C in the high-byte or 1/256°C LSB."

[Registers.FullCap]
addr = 0x035
backup = "nFullCapNom"
description = "This register holds the calculated full capacity of the cell based on all inputs from the ModelGauge m5 algorithm including empty compensation. A new full-capacity value is calculated continuously as application conditions change."

[Registers.RComp0]
addr = 0x038
description = "The nRComp0 register holds characterization information critical to computing the open circuit voltage of a cell under loaded conditions."

[Registers.TempCo]
addr = 0x039
description = "The nTempCo register holds temperature compensation information for the nRComp0 register value."
type = "special"

[Registers.VEmpty]
addr = 0x03A
type = "special"
initial = 0x9659
description = "The nVempty register sets thresholds related to empty detection during operation."

[Registers.VEmpty.VE]
name = "Empty Voltage"
msb = 15
lsb = 7
description = "Sets the voltage level for detecting empty. A 10mV resolution gives a 0 to 5.11V range. This value is written to 3.3V after reset if nonvolatile backup is disabled."
unit = "V"
step = 0.01

[Registers.VEmpty.VR]
name = "Recovery Voltage"
msb = 6
lsb = 0
description = "Sets the voltage level for clearing empty detection. Once the cell voltage rises above this point, empty voltage detection is re-enabled. A 40mV resolution gives a 0 to 5.08V range. This value is written to 3.88V after reset if nonvolatile backup is disabled."
unit = "V"
step = 0.04

[Registers.FStat]
addr = 0x03D
x_mask = 0xFCBE
type = "ro"
description = "The FStat register is a read-only register that monitors the status of the ModelGauge algorithm. Do not write to this register location."

[Registers.FStat.RelDt]
name = "Relaxed cell detection"
position = 9
description = "This bit is set to 1 whenever the ModelGauge m5 algorithm detects that the cell is in a fully relaxed state. This bit is cleared to 0 whenever a current greater than the load threshold is detected."

[Registers.FStat.EDet]
name = "Empty Detection"
position = 8
description = "This bit is set to 1 when the IC detects that the cell empty point has been reached. This bit is reset to 0 when the cell voltage rises above the recovery threshold. See the VEmpty register for details."

[Registers.FStat.RelDt2]
name = "Long Relaxation"
position = 6
description = "This bit is set to 1 whenever the ModelGauge m5 algorithm detects that the cell has been relaxed for a period of 48 to 96 minutes or longer. This bit is cleared to 0 whenever the cell is no longer in a relaxed state."

[Registers.FStat.DNR]
name = "Data Not Ready"
position = 0
description = "This bit is set to 1 at cell insertion and remains set until the output registers have been updated. Afterwards, the IC clears this bit indicating the fuel gauge calculations are now up to date. This takes between 445ms and 1.845s depending on whether the IC was in a powered state prior to the cell-insertion event. "

[Registers.Timer]
addr = 0x03E
type = "ro"
description = "This register holds timing information for the fuel gauge. It is available to the user for debugging purposes. The Timer register LSb is equal to 175.8ms giving a full-scale range of 0 to 3.2 hours."
unit = "s"
step = 0.1758

[Registers.AvgDieTemp]
addr = 0x040
description = "The AvgDieTemp register reports a 4-sample filtered average of the DieTemp register."
unit = "°C"
step = 0.00390625
signed = true

[Registers.QRTable30]
addr = 0x042
initial = 0x0880
derived_from = "QRTable00"

[Registers.VFRemCap]
addr = 0x04A
unit = "µVh"
description = "The VFRemCap register holds the remaining capacity of the cell as determined by the voltage fuel gauge before any empty compensation adjustments are performed."

[Registers.QH]
addr = 0x04D
unit = "µVh"
description = "The QH register displays the raw coulomb count generated by the device. This register is used internally as an input to the mixing algorithm. Monitoring changes in QH over time can be useful for debugging device operation."

[Registers.QL]
addr = 0x04E

# individual registers slave address 0x6C (see table 91 in the datasheet)
[Registers.Command]
addr = 0x060
i2c_addr = 0x6C
description = "Command Register"

[Registers.CommStat]
addr = 0x061
description = "CommStat Register"

[Registers.Lock]
addr = 0x07F
description = "Lock register"

# ModelGauge m5 memory map continued slave address 0x6C (see table 92 in the datasheet)
[Registers.RelaxCfg]
addr = 0x0A0
initial = 0x2039
type = "special"
description = "The nRelaxCfg register defines how the IC detects if the cell is in a relaxed state. See Figure 28. For a cell to be considered relaxed, current flow through the cell must be kept at a minimum while the change in the cell’s voltage over time, dV/dt, shows little or no change. If AvgCurrent remains below the LOAD threshold while VCell changes less than the dV threshold over two consecutive periods of dt, the cell is considered relaxed."

[Registers.RelaxCfg.LOAD]
description = "Sets the threshold, which the AvgCurrent register is compared against. The AvgCurrent register must remain below this threshold value for the cell to be considered unloaded. Load is an unsigned 7-bit value where 1 LSb = 50μV. The default value is 800μV."
msb = 15
lsb = 9
unit = "μV"
step = 50

[Registers.RelaxCfg.dV]
description = "Sets the threshold, which VCell is compared against. If the cell’s voltage changes by less than dV over two consecutive periods set by dt, the cell is considered relaxed; dV has a range of 0 to 40mV where 1 LSb = 1.25mV. The default value is 3.75mV."
msb = 8
lsb = 4
unit = "mV"
step = 1.25

[Registers.RelaxCfg.dt]
description = "Sets the time period over which change in VCell is compared against dV. If the cell’s voltage changes by less than dV over two consecutive periods set by dt, the cell is considered relaxed. The default value is 1.5 minutes. The comparison period is calculated as: Relaxation period = 2(dt-8) x 45s"
msb = 3
lsb = 0

[Registers.LearnCfg]
addr = 0x0A1
initial = 0x4686
ones_mask = 0x4686
zeros_mask = 0xB909
description = "The nLearnCfg register controls all functions relating to adaptation during operation."

[Registers.LearnCfg.LS]
name = "Learn Stage"
msb = 6
lsb = 4
description = "The Learn Stage value controls the influence of the voltage fuel gauge on the mixing algorithm. Learn Stage defaults to 0h, making the voltage fuel gauge dominate. Learn Stage then advances to 7h over the course of two full cell cycles to make the coulomb counter dominate. Host software can write the Learn Stage value to 7h to advance to the final stage at any time. Writing any value between 1h and 6h is ignored."

[Registers.MaxPeakPower]
addr = 0x0A4

[Registers.SusPeakPower]
addr = 0x0A5

[Registers.PackResistance]
addr = 0x0A6

[Registers.SysResistance]
addr = 0x0A7

[Registers.MinSysVoltage]
addr = 0x0A8

[Registers.MPPCurrent]
addr = 0x0A9

[Registers.SPPCurrent]
addr = 0x0AA

[Registers.Config2]
addr = 0x0AB
zeros_mask = 0x4023
ones_mask = 0x0010

[Registers.Config2.POR_CMD]
position = 15
name = "Firmware Restart"
description = "Set this bit to 1 to restart IC firmware operation without performing a recall of nonvolatile memory into RAM. This allows different IC configurations to be tested without changing nonvolatile memory settings. This bit is set to 0 at power-up and automatically clears itself after firmware restart."

[Registers.Config2.AtRtEn]
position = 13
description = ""

[Registers.Config2.ADCFIFOen]
position = 12
name = "ADC FIFO Enable"
description = "If continuous mode is disabled, a single-cycle acquisition mode for ADC FIFO is enabled by setting Config2.ADCFIFOen = 1."

[Registers.Config2.POWR]
msb = 11
lsb = 8
description = "Sets the time constant for the AvgPower register. The default POR value of 0000b gives a time constant of 0.7s. The equation setting the period is: AvgPower time constant = 45s x 2(POWR-6)"

[Registers.Config2.dSOCen]
position = 7

[Registers.Config2.TAlrtEn]
position = 6
name = "Temperature Alert Enable"
description = "Set this bit to 1 to enable temperature based alerts. Write this bit to 0 to disable temperature alerts. This bit is set to 1 at power-up."

[Registers.Config2.DRCfg]
msb = 3
lsb = 2
name = "Deep Relax Time Configuration"

[Registers.Config2.DRCfg.values]
0 = "0.8h-1.6h"
1 = "1.6h-3.2h"
2 = "3.2h-6.4h"
3 = "6.4h-12.8h"

[Registers.IAlrtTh]
addr = 0x0AC
type = "special"
initial = 0x7F80
description = "The nIAlrtTh register shown in Table 89 sets upper and lower limits that generate an ALRT pin interrupt if exceeded by the Current register value. The upper 8 bits set the maximum value and the lower 8 bits set the minimum value. Interrupt threshold limits are selectable with 400μV resolution over the full operating range of the Current register. At power-up, the thresholds default to their maximum settings unless they are configured to be restored from nonvolatile memory instead by setting the nNVCfg1.enAT bit."

[Registers.IAlrtTh.CURRMAX]
name = "Maximum Current Threshold"
msb = 15
lsb = 8
signed = true
unit = "μV"
step = 400
description = "An alert is generated if the current register reading exceeds this value. This field is signed 2's complement with 400μV LSb resolution to match the upper byte of the Current register."

[Registers.IAlrtTh.CURRMIN]
name = "Minimum Current Threshold"
msb = 7
lsb = 0
signed = true
unit = "μV"
step = 400
description = "An alert is generated if the current register reading falls below this value. This field is signed 2's complement with 400μV LSb resolution to match the upper byte of the Current register."

[Registers.MinVolt]
addr = 0x0AD

[Registers.MinCurr]
addr = 0x0AE

# TODO: field decsriptions of ProtAlrt
[Registers.ProtAlrt]
addr = 0x0AF
name = "Protection Alert Register"
description = "The Protection Alerts register contains a history of any protection events that have been logged by the device. If any bit of ProtAlrt is 1, then the Status.PA bit is also 1 if Config.ProtAlrtEn = 1. Once a bit is set, it remains set until cleared by the host. The Alert pin is driven low if Config.AEn = 1 and Config.ProtAlrtEn = 1. The bits in ProtAlrt mirror the bits in ProtStatus with the exception of the LDET bit."

[Registers.ProtAlrt.ChgWDT]
position = 15
description = "Charge communication watchdog timer"

[Registers.ProtAlrt.TooHotC]
position = 14
description = "Overtemperature while charging"

[Registers.ProtAlrt.Full]
position = 13
description = "Full detection"

[Registers.ProtAlrt.TooColdC]
position = 12
description = "Undertemperature while charging"

[Registers.ProtAlrt.OVP]
position = 11
description = "Overvoltage"

[Registers.ProtAlrt.OCCP]
position = 10
description = "Overcharge current"

[Registers.ProtAlrt.Qovflw]
position = 9
description = "Capacity overflow"

[Registers.ProtAlrt.PreqF]
position = 8
description = "Prequal timeout"

[Registers.ProtAlrt.Imbalance]
position = 7
description = "Multicell imbalance"

[Registers.ProtAlrt.PermFail]
position = 6
description = "Permanent failure"

[Registers.ProtAlrt.DieHot]
position = 5
description = "Overtemperature for die temperature"

[Registers.ProtAlrt.TooHotD]
position = 4
name = "Overtemperature while discharging"

[Registers.ProtAlrt.UVP]
position = 3
description = "Undervoltage"

[Registers.ProtAlrt.ODCP]
position = 2
description = "Overdischarge current"

[Registers.ProtAlrt.ResDFault]
position = 1

[Registers.ProtAlrt.LDet]
position = 0
description = "Leakage detection"

[Registers.Status2]
addr = 0x0B0
type = "special"
x_mask = 0xFFFD

[Registers.Status2.Hib]
position = 1
name = "Hibernate Status"
description = "This bit is set to a 1 when the device is in hibernate mode or 0 when the device is in active mode. Hib is set to 0 at power-up."

[Registers.Power]
addr = 0x0B1
description = "Instantaneous power calculation from immediate current and voltage. LSB is 1.6mW with a 5mΩ sense resistor."

[Registers.VRipple]
addr = 0x0B2
type = "special"
description = "The VRipple register holds the slow average RMS value of the VCell register reading variation compared to the AvgVCell register. The default filter time is 22.5s. See the nRippleCfg register description. VRipple has an LSb weight of 1.25mV/ 128."
step = 0.009765625

[Registers.AvgPower]
addr = 0x0B3
description = "Filtered Average Power from the power register. LSB is 1.6mW with a 5mΩ sense resistor. Filter bits located in Config2.POWR."

[Registers.TTFCfg]
addr = 0x0B5
type = "special"

[Registers.CVMixCap]
addr = 0x0B6
description = "defined as the approximate state of charge where the charge transitions from the constant current portion of the charge cycle to the constant voltage portion of the charge current. See Figure 29. CVMixCapRatio has an LSB of 0.5mAh."
unit = "mAh"
step = 0.5

[Registers.CVHalfTime]
addr = 0x0B7
unit = "hours"
description = "The amount of time in the constant voltage portion of the charge cycle for the current to taper to half of the charging current in the constant current portion of the charge cycle. See Figure 29. CVHalfTime has an LSB of 0.0001953125 hours (~0.7 seconds)."
step = 0.0001953125

[Registers.CGTempCo]
addr = 0x0B8
initial = 0x20C8
description = "Set nNVCfg2.enMet = 1 to use CGTempCo to adjust current measurements for temperature. CGTempCo has a range of 0% to 3.1224% per degrees Celsius with a step size of 3.1224/65536 percent per degrees Celsius. If the nNVCfg1.enMtl bit is clear CGTempCo defaults to a value of 20C8h (compensation for copper) or 0.4% per degrees Celsius which is the approximate temperature coefficient of a copper trace. If the nNVCfg1.enMtl bit is set CGTempCo restores from nCGTempCo (1C9h) after IC reset allowing a custom sense resistor temperature coefficient to be used. Factory Default Value: 0000h. Alternate Initial Value: 20C8h."
max = 3.1224
unit = "%"
step = 0.00004764404296875

[Registers.AgeForecast]
addr = 0x0B9
type = "special"
description = "The AgeForecast register displays the estimated cycle life of the application cell. The AgeForecast value should be compared against the Cycles (017h) register to determine the estimated number of remaining cell cycles. This is accomplished by accumulating the capacity loss per cycle as the cell ages. The result becomes more accurate with each cycle measured. The AgeForecast register has a full range of 0 cycles to 16383 cycles with a 25% LSb. This register is recalculated from learned information at power-up."
unit = "%"
step = 25

[Registers.TimerH]
addr = 0x0BE
type = "special"
backup = "nTimerH (1AFh) if nNVCfg2.enT is set"
description = "This register allows the IC to track the age of the cell. An LSb of 3.2 hours gives a full-scale range for the register of up to 23.94 years. If enabled, this register is periodically backed up to nonvolatile memory as part of the learning function."
unit = "hours"
step = 3.2

[Registers.SOCHold]
addr = 0x0D0
type = "special"
description = "The SOCHold register configures operation of the hold before empty feature and also the enable bit for 99% hold during charge. The default value for SOCHold is 1002h."
zeros_mask = 0xE000

[Registers.SOCHold.'99%HoldEn']
position = 12
description = "Enable bit for 99% hold feature during charging. When enabled, RepSOC holds a maximum value of 99% until Full Qualified is reached."

[Registers.SOCHold.EmptyVoltHold]
msb = 11
lsb = 5
description = "The positive voltage offset that is added to VEmpty. At VCell = VEmpty + EmptyVoltHold point, the empty detection/learning is occured. EmptyVoltHold has an LSb of 10mV giving a range of 0 to 1270mV."
unit = "V"
step = 0.01

[Registers.SOCHold.EmptySocHold]
msb = 4
lsb = 0
description = "It is the RepSOC at which RepSOC is held constant. After empty detection/learning occurs, RepSOC update continues as expected. EmptySocHold has an LSb of 0.5%, giving it a full range of 0 to 15.5%."
unit = "%"
step = 0.5

[Registers.AvGCell4]
addr = 0x0D1
unit = "voltage"
description = "An 8-sample filtered average of the Cell4 register readings."

[Registers.AvgCell3]
addr = 0x0D2
unit = "voltage"
description = "An 8-sample filtered average of the Cell3 register readings."

[Registers.AvgCell2]
addr = 0x0D3
unit = "voltage"
description = "An 8-sample filtered average of the Cell2 register readings."

[Registers.AvgCell1]
addr = 0x0D4
unit = "voltage"
description = "An 8-sample filtered average of the Cell1 register readings."

[Registers.CELL4]
addr = 0x0D5
unit = "voltage"
description = "Contains the latest voltage measurement of cell 4."

[Registers.CELL3]
addr = 0x0D6
unit = "voltage"
description = "Contains the latest voltage measurement of cell 2."

[Registers.CELL2]
addr = 0x0D7
unit = "voltage"
description = "Contains the latest voltage measurement of cell 2."

[Registers.CELL1]
addr = 0x0D8
unit = "voltage"
description = "Contains the latest voltage measurement of cell 1."

[Registers.ProStatus]
addr = 0x0D9
description = "The Protection Status register contains the fault states of the protection state machine."

[Registers.ProStatus.ChgWDT]
position = 15
description = "Charge communication watchdog timer"

[Registers.ProStatus.TooHotC]
position = 14
description = "Overtemperature while charging"

[Registers.ProStatus.Full]
position = 13
description = "Full detection"

[Registers.ProStatus.TooColdC]
position = 12
description = "Undertemperature while charging"

[Registers.ProStatus.OVP]
position = 11
description = "Overvoltage"

[Registers.ProStatus.OCCP]
position = 10
description = "Overcharge current"

[Registers.ProStatus.Qovflw]
position = 9
description = "Capacity overflow"

[Registers.ProStatus.PreqF]
position = 8
description = "Prequal timeout"

[Registers.ProStatus.Imbalance]
position = 7
description = "Multicell imbalance"

[Registers.ProStatus.PermFail]
position = 6
description = "Permanent failure"

[Registers.ProStatus.DieHot]
position = 5
description = "Overtemperature for die temperature"

[Registers.ProStatus.TooHotD]
position = 4
name = "Overtemperature while discharging"

[Registers.ProStatus.UVP]
position = 3
description = "Undervoltage"

[Registers.ProStatus.ODCP]
position = 2
description = "Overdischarge current"

[Registers.ProStatus.ResDFault]
position = 1

[Registers.ProStatus.Ship]
position = 0
description = "Indicates ship state"

[Registers.Batt]
addr = 0x0DA
description = "The Batt registers contains the total pack voltage measured inside the protector on a 20.48V scale with an LSB of 0.3125mV."
type = "special"
unit = "V"
step = 0.0003125

[Registers.PCKP]
addr = 0x0DB
description = "The PCKP register contains the voltage between PACK+ and GND on a 20.48V scale with an LSB of 0.3125mV."
type = "special"
unit = "V"
step = 0.0003125

[Registers.AtQResidual]
addr = 0x0DC
unit = "µVh"
description = "The AtQResidual register displays the residual charge held by the cell at the theoretical load-current level entered into the AtRate register."

[Registers.AtTTe]
addr = 0x0DD
description = "The AtTTE register can be used to estimate time-to-empty for any theoretical current load entered into the AtRate register. The AtTTE register displays the estimated time-to-empty for the application by dividing AtAvCap by the AtRate register value. The AtTTE register has a maximum value of 102.3 hours. When AtTTE is larger than the maximum value, the AtTTE register saturates and contains the maximum value (FFFFh). The host can calculate time values longer that the maximum register value with the following equation: AtTTECALCULATED (hours) = AtAvCap(mAh)/AtRate(mA)"
unit = "s"
step = 5.6195068359375

[Registers.AtAvSOC]
addr = 0x0CE
description = "The AtAvSOC register holds the theoretical state of charge of the cell based on the theoretical current load of the AtRate register. The register value is stored as a percentage with a resolution of 0.0039% per LSB. If a 1% resolution state-ofcharge value is desired, the host can read only the upper byte of the register instead."
unit = "%"
step = 0.0039

[Registers.AtAvCap]
addr = 0x0DF
unit = "µVh"
description = "The AtAvCap register holds the estimated remaining capacity of the cell based on the theoretical load current value of the AtRate register. The value is stored in terms of µVh and must be divided by the application sense-resistor value to determine the remaining capacity in mAh."

[Registers.nXTable0]
addr = 0x180
type = "special"
access = "rw"
description = "Cell characterization information used by the ModelGauge algorithm to determine capacity versus operating conditions. This table comes from battery characterization data. These are nonvolatile memory locations."

[Registers.nXTable1]
addr = 0x181
access = "rw"
derived_from = "nXTable0"

[Registers.nXTable2]
access = "rw"
addr = 0x182
derived_from = "nXTable0"

[Registers.nXTable3]
access = "rw"
addr = 0x183
derived_from = "nXTable0"

[Registers.nXTable4]
access = "rw"
addr = 0x184
derived_from = "nXTable0"

[Registers.nXTable5]
access = "rw"
addr = 0x185
derived_from = "nXTable0"

[Registers.nXTable6]
access = "rw"
addr = 0x186
derived_from = "nXTable0"

[Registers.nXTable7]
access = "rw"
addr = 0x187
derived_from = "nXTable0"

[Registers.nXTable8]
access = "rw"
addr = 0x188
derived_from = "nXTable0"

[Registers.nXTable9]
access = "rw"
addr = 0x189
derived_from = "nXTable0"

[Registers.nXTable10]
addr = 0x18A
derived_from = "nXTable0"

[Registers.nXTable11]
addr = 0x18B
derived_from = "nXTable0"

[Registers.nValrtTh]
access = "rw"
addr = 0x18C
derived_from = "VAlrtTh"

[Registers.nTAlrtTH]
access = "rw"
addr = 0x18D
derived_from = "TAlrtTh"

[Registers.nIAlrtTh]
access = "rw"
addr = 0x18E
derived_from = "IAlrtTh"

[Registers.nSAlrtTh]
access = "rw"
addr = 0x18F
derived_from = "SAlrtTh"

[Registers.nOCVTable0]
access = "rw"
addr = 0x190
description = "Cell characterization information used by the ModelGauge algorithm to determine capacity versus operating conditions. This table comes from battery characterization data. These are nonvolatile memory locations."

[Registers.nOCVTable1]
access = "rw"
addr = 0x191
derived_from = "nOCVTable0"

[Registers.nOCVTable2]
access = "rw"
addr = 0x192
derived_from = "nOCVTable0"

[Registers.nOCVTable3]
access = "rw"
addr = 0x193
derived_from = "nOCVTable0"

[Registers.nOCVTable4]
access = "rw"
addr = 0x194
derived_from = "nOCVTable0"

[Registers.nOCVTable5]
addr = 0x195
derived_from = "nOCVTable0"

[Registers.nOCVTable6]
addr = 0x196
derived_from = "nOCVTable0"

[Registers.nOCVTable7]
addr = 0x197
derived_from = "nOCVTable0"

[Registers.nOCVTable8]
addr = 0x198
derived_from = "nOCVTable0"

[Registers.nOCVTable9]
addr = 0x199
derived_from = "nOCVTable0"

[Registers.nOCVTable10]
addr = 0x19A
derived_from = "nOCVTable0"

[Registers.nOCVTable11]
addr = 0x19B
derived_from = "nOCVTable0"

[Registers.nIChgTerm]
access = "rw"
addr = 0x19C
derived_from = "IChgTerm"

[Registers.nFilterCfg]
access = "rw"
addr = 0x19D
derived_from = "FilterCfg"

[Registers.nVEmpty]
access = "rw"
addr = 0x19E
derived_from = "VEmpty"

[Registers.nLearnCfg]
addr = 0x19F
derived_from = "LearnCfg"
access = "rw"

[Registers.nQRTable00]
addr = 0x1A0
description = "The nQRTable00 to nQRTable30 register locations contain characterization information regarding cell capacity that is not available under certain application conditions."
access = "rw"

[Registers.nQRTable10]
addr = 0x1A1
derived_from = "nQRTable00"

[Registers.nQRTable20]
addr = 0x1A2
derived_from = "nQRTable00"

[Registers.nQRTable30]
addr = 0x1A3
derived_from = "nQRTable00"

[Registers.nCycles]
addr = 0x1A4
derived_from = "nQRTable00"

[Registers.nFullCapNom]
addr = 0x1A5
derived_from = "FullCapNom"

[Registers.nRComp0]
addr = 0x1A6
derived_from = "RComp0"

[Registers.nTempCo]
addr = 0x1A7
derived_from = "TempCo"

[Registers.nBattStatus]
addr = 0x1A8
description = "The Battery Status register contains the permanent battery status information. If nProtCfg.PFen = 1, then a permanent fail results in permanently turning the FETs off to ensure the safety of the battery and the PFAIL pin is driven high."

[Registers.nBattStatus.PermFail]
position = 15
name = "Permanent Failure"
description = "This bit is set if any permanent failure is detected."

[Registers.nBattStatus.OVPF]
position = 14
name = "Overvoltage Protection Failure"

[Registers.nBattStatus.OTPF]
position = 13
name = "Overtemperature Protection Failure"

[Registers.nBattStatus.CFETFs]
position = 12
name = "Charge FET failure-short detected"
description = "If the IC detects that the charge FET is shorted and cannot be opened, it sets the CFETFs bit and the PermFail bit. This function is enabled with nProtCfg.FetPFEn."

[Registers.nBattStatus.DFETFs]
position = 11
name = "Discharge FET failure-short detected"
description = "If the IC detects that the discharge FET is shorted and cannot be opened, it sets the DFETFs and the PermFail bit. This function is enabled with nProtCfg.FetPFEn."

[Registers.nBattStatus.FETFo]
position = 10
name = "Discharge FET failure open"
description = "If the IC detects an open FET failure it sets FETFo. In this case, if the IC detects either CHG or DIS FET to have failed open, then it sets FETFo. This function is enabled with nProtCfg.FetPFEn."

[Registers.nBattStatus.LDet]
position = 9
name = "Leakage Detection Fault"
description = "This bit is set when a leakage detection fault has been detected."

[Registers.nBattStatus.ChksumF_UVPF]
position = 8
name = "Checksum Failure or Undervoltage Permanent Failure"
description = """ChksumF related: NVM configuration registers checksum failure. In the case of a checksum failure, the device sets the PermFail bit but does not write it to NVM in order to prevent using an additional NVM write. This allows the PermFail bit to be cleared by the host so that the INI file can be reloaded.
UVPF related: This bit is set when VCell is less than the UnderVoltage Permanent Failure Threshold."""

[Registers.nBattStatus.LeakCurr]
name = "Leakage Current"
description = "Leakage current is an unsigned 8-bit result of leakage current from self-discharge in a cell. This field saves the leakage current from the LeakCurrRep register. The LSB for this field is 3.125μV (or 0.625mA with a 5mΩ RSENSE with a range of 0mA to 159.375mA)."
msb = 7
lsb = 0
unit = "µV"
step = 3.125

[Registers.nFullCapRep]
addr = 0x1A9
derived_from = "FullCapRep"

[Registers.nVoltTemp]
addr = 0x1AA
backup = "AvgVCell and AvgTA registers if nNVCfg2.enVT = 1"
description = "This register has dual functionality depending on configuration settings. If nNVCfg2.enVT = 1, this register provides nonvolatile back up of the AvgVCell and AvgTA registers. Alternatively, if nNVCfg0.enAF = 1, this register stores an accumulated age slope value to be used with the Age Forecasting algorithm. Regardless of which option is enabled, this register is periodically saved to nonvolatile memory as part of the learning function. If neither option is enabled, this register can be used as general-purpose user memory."

[Registers.nVoltTemp.AvgCell]
description = "AvgVCell Upper 9 bits"
msb = 15
lsb = 7
unit = "mV"
step = 0.078125

[Registers.nVoltTemp.AvgTA]
description = "AvgTA Upper 7 bits"
msb = 6
lsb = 0
unit = "°C"
step = 0.00390625
signed = true

[Registers.nMaxMinCurr]
addr = 0x1AB
derived_from = "MaxMinCurr"

[Registers.nMaxMinVolt]
derived_from = "MaxMinVolt"
addr = 0x1AC

[Registers.nMaxMinTemp]
addr = 0x1AD
derived_from = "MaxMinTemp"

[Registers.nFaultLog_nFullCapFlt]
addr = 0x1AE
description = "This register has dual functionality depending on configuration settings. If nNVCfg2.enFL = 1, the nFaultLog register contains a history of protection events that have been logged at any moment by the device during the log interval. Alternatively, if nNVCfg0.enAF = 1, the register becomes repurposed for Age Forecasting data. If neither option is enabled, this register can be used as general-purpose user memory. This register is periodically saved to nonvolatile memory as part of the life-logging function."

[Registers.nFaultLog_nFullCapFlt.TooHotC]
position = 7
description = "Overtemperature during charge"

[Registers.nFaultLog_nFullCapFlt.TooColdC]
position = 6
description = "Undertemperature during charge"

[Registers.nFaultLog_nFullCapFlt.OVP]
position = 5
description = "Overvoltage protection"

[Registers.nFaultLog_nFullCapFlt.OCCp]
position = 4
description = "Overcharge current protection"

[Registers.nFaultLog_nFullCapFlt.DieHot]
position = 3
description = "Overtemperature for die temperature"

[Registers.nFaultLog_nFullCapFlt.Imbalance]
position = 2
description = "Multicell Imbalance"

[Registers.nFaultLog_nFullCapFlt.UVP]
position = 1
description = "Undervoltage Protection"

[Registers.nFaultLog_nFullCapFlt.ODCP]
position = 0
description = "Overdischarge Current Protection"

[Registers.nTimerH]
addr = 0x1AF
derived_from = "TimerH"

[Registers.nConfig]
addr = 0x1B0
derived_from = "Config"
zeros_mask = 0x0000

[Registers.nConfig.PAen]
position = 15
name = "Protection Alert Enable"
description = "Set PAen = 1 to enable this feature that saves the protector faults (TooHotC, TooColdC, OVP, OCCP, DieHot, TooHotD, UVP, ODCP, LDet) into the low byte of the nBattStatus register. After each life logging write to NVM, the low byte of nBattStatus is cleared."

[Registers.nConfig.dSOCen]
position = 1
name = "SOC Change Alert Enable"
description = "Set this bit to 1 to enable the Status.dSOCi bit function. Write this bit to 0 to disable the Status.dSOCi bit. This bit is set to 0 at power-up."

[Registers.nRippleCfg]
addr = 0x1B1
type = "special"
initial = 0x0204
description = "The nRippleCfg register configures ripple measurement and ripple compensation. The recommended value for this register is 0x0204."

[Registers.nRippleCfg.kDV]
msb = 15
lsb = 3
description = "Sets the corresponding amount of capacity to compensate proportional to the ripple."

[Registers.nRippleCfg.NR]
msb = 2
lsb = 0
description = "Sets the filter magnitude for ripple observation as defined by the following equation giving a range of 1.4 seconds to 180 seconds. Ripple Time Range = 1.4 seconds x 2NR"

[Registers.nMiscCfg]
addr = 0x1B2
derived_from = "MiscCfg"

[Registers.nDesignCap]
addr = 0x1B3
derived_from = "DesignCap"
restore = "DesignCap (018h) if nNVCfg0.enDC is set"

[Registers.nSBSCfg]
addr = 0x1B4
x_mask = 0x43C1
initial = 0xA5B9
description = "The nSBSCfg register manages settings for SBS mode operation of the IC."

[Registers.nSBSCfg.CapMD]
position = 15
description = "Selects the sBatteryMode.CapMd bit default setting when operating in SBS mode. CapMd resets to 0 every time a pack removal occurs as detected by floating communication lines."

[Registers.nSBSCfg.SBS_FullReleaseThr]
msb = 13
lsb = 10
description = "SBS Full Release Threshold. (DevName 420Ah or newer) sBatteryStatus.Full bit is cleared when SOC<SBS_FullReleaseThr. Configurable between 85% and 99% with a 1% LSB."
zero_code_value = 85
max = 99
step = 1
unit = "%"

[Registers.nSBSCfg.SBS_RSenseSel]
msb = 5
lsb = 4
name = "RSense Selection"
description = " (DevName 420Ah or newer) SBS module can support 1.25mOhm, 2.5mOhm, 5mOhm and 10mOhm (Previously only 2.5mOhm sense resistor was supported with DevName 4209h). All the SBS registers for capacity and current are scaled based on RSenseSel."
unit = "mΩ"

[Registers.nSBSCfg.SBS_RSenseSel.values]
0 = 1.25
1 = 2.5
2 = 5
3 = 10

[Registers.nSBSCfg.WPen]
position = 3
name = "Write Protection Enable"
description = "Set WPen to 0 for SBS mode."

[Registers.nSBSCfg.MECfg]
msb = 2
lsb = 1
description = "Configures sMaxError register output when operating in SBS mode."

[Registers.nSBSCfg.MECfg.values]
0 = "Always report 0% error"
1 = "Always report 1% error"
2 = "Report actual experienced error"
3 = "Always report 3% error"

[Registers.nPackCfg]
addr = 0x1B5
type = "special"
description = "The nPackCfg register configures the number of cells and thermistors (and thermistor type) in the battery pack. It also configures the charge pump and backup regulator voltage levels. nPackCfg configuration must match the pack hardware for the proper operation of the IC."
zeros_mask = 0x14E0

[Registers.nPackCfg.AOCfg]
msb = 15
lsb = 14
description = "Always-on Regulator Configuration."

[Registers.nPackCfg.values]
0 = "AOLDO is disabled."
1 = "AOLDO is enabled. Output is 3.4V."
2 = "AOLDO is enabled. Output is 1.8V."
3 = "AOLDO is enabled. Output is 3.4V."

[Registers.nPackCfg.THType]
position = 11
name = "Thermistor Type"
description = "If using 10kΩ NTC thermistor, set THType = 0. If using 100kΩ NTC thermistor, set THType = 1."

[Registers.nPackCfg.CPCfg]
msb = 9
lsb = 8
name = "Charge Pump Voltage Configuration (DevName 420Ah or newer)"
description = "Set according to the desired gate drive. Note that there is a trade-off in quiescent vs. gate-drive. Set CPCfg = {00b,01b,10b} for {6V, 8V, 10V} settings."

[Registers.nPackCfg.CPCfg.values]
0 = "6V"
1 = "8V"
2 = "10V"

[Registers.nPackCfg.NThrms]
msb = 4
lsb = 2
description = "Number of Thermistor Channels"

[Registers.nPackCfg.NThrms.values]
0 = "only die temp"
1 = "die temp and TH1 thermistor channel enabled"
2 = "die temp and TH1 and TH2 thermistor channels enabled"
3 = "die temp and TH1, TH2, and TH3 thermistor channels enabled"
4 = "die temp and TH1, TH2, TH3 and TH4 thermistor channels enabled"

[Registers.nPackCfg.NCELLS]
msb = 1
lsb = 0
name = "Number of Cells"
description = "This field configures the IC for the number of cells in series in the cell pack. Set NCELLS = cellcount-2."

[Registers.nRelaxCfg]
addr = 0x1B6
initial = 0x2039
type = "special"
description = "The nRelaxCfg register defines how the IC detects if the cell is in a relaxed state. See Figure 28. For a cell to be considered relaxed, current flow through the cell must be kept at a minimum while the change in the cell’s voltage over time, dV/dt, shows little or no change. If AvgCurrent remains below the LOAD threshold while VCell changes less than the dV threshold over two consecutive periods of dt, the cell is considered relaxed."

[Registers.nRelaxCfg.LOAD]
msb = 15
lsb = 9
description = "Sets the threshold, which the AvgCurrent register is compared against. The AvgCurrent register must remain below this threshold value for the cell to be considered unloaded. Load is an unsigned 7-bit value where 1 LSb = 50μV. The default value is 800μV."
unit = "μV"
step = 50

[Registers.nRelaxCfg.dV]
description = "Sets the threshold, which VCell is compared against. If the cell’s voltage changes by less than dV over two consecutive periods set by dt, the cell is considered relaxed; dV has a range of 0 to 40mV where 1 LSb = 1.25mV. The default value is 3.75mV."
msb = 8
lsb = 4
unit = "mV"
step = 1.25
max = 40

[Registers.nRelaxCfg.dt]
description = "Sets the time period over which change in VCell is compared against dV. If the cell’s voltage changes by less than dV over two consecutive periods set by dt, the cell is considered relaxed. The default value is 1.5 minutes. The comparison period is calculated as: Relaxation period = 2(dt-8) x 45s"
msb = 3
lsb = 0

[Registers.nConvgCfg]
addr = 0x1B7
type = "special"
initial = 0x2241
description = "The nConvgCfg register configures operation of the converge-to-empty feature. The nNVCfg1.CTE bit must be set to enable converge-to-empty functionality. If nNVCfg1.CTE is clear, this register can be used as general-purpose data storage."

[Registers.nConvgCfg.RepLow]
msb = 15
lsb = 12
description = "Sets the threshold below which RepCap begins to bend upwards. The RepLow field LSb is 2% giving a full scale range from 0% to 30%."
unit = "%"
step = 2

[Registers.nConvgCfg.VoltLowOff]
msb = 11
lsb = 7
description = "When the AvgVCell register value drops below the VoltLow threshold, RepCap begins to bend downwards by a ratio defined by the following equation. VoltLowOff has an LSb of 20mV giving a range of 0 to 620mV. (AvgVCell - VEmpty)/VoltLowOff"
unit = "mV"
step = 20

[Registers.nConvgCfg.MinSlopeX]
msb = 6
lsb = 3
description = "Sets the amount of slope shallowing which occurs when RepSOC falls below RepLow. MinSlopeX LSb corresponds to a ratio of 1/16 giving a full range of 0 to 15/16."
step = 0.0625

[Registers.nConvgCfg.RepL_per_stage]
msb = 2
lsb = 0
description = "Adjusts the RepLow threshold setting depending on the present learn stage using the following equation. This allows the RepLow threshold to be at higher levels for earlier learn states. RepL_per_stage has an LSb of 1% giving a range of 0% to 7%. RepLow Threshold = RepLow Field Setting + RemainingStages x RepL_per_stage"
unit = "%"

[Registers.nNVCfg0]
addr = 0x1B8
type = "special"
initial = 0x0A00
zeros_mask = 0x1000
ones_mask = 0x0800
description = "The nNVCfg0 register manages nonvolatile memory backup of device and fuel gauge register RAM locations. Each bit of the nNVCfg0 register, when set, enables a given register location to be restored from a corresponding nonvolatile memory location after reset of the IC. If nonvolatile restore of a given register is not enabled, that location initializes to a default value after reset instead. See the individual register descriptions for details."

[Registers.nNVCfg0.enOCV]
position = 15
name = "Enable OCVTable restore"
description = "Set this bit to enable nOCVTable register locations to be used for cell characterization data. When this bit is clear, the IC uses the default cell model and all nOCVTable register locations can be used as general-purpose user memory."

[Registers.nNVCfg0.enX]
position = 14
name = "nable XTable restore"
description = "Set this bit to enable nXTable register locations to be used for cell characterization data. When this bit is clear, the IC uses the default cell model and all nXTable register locations can be used as generalpurpose user memory."

[Registers.nNVCfg0.enSHA]
position = 13
description = "Set to 1 to configure the MTP at address 0x1DC to 0x1DF as SHA space. Set to 0 to configure address 0x1DC to 0x1DF as user MTP."

[Registers.nNVCfg0.enFCfg]
position = 10
name = "Enable FilterCfg restore"
description = "Set this bit to enable the FilterCfg register to be restored after reset by the nFilterCfg register. When this bit is clear, FilterCfg restores with its alternate initialization value and nFilterCfg can be used for general-purpose data storage."

[Registers.nNVCfg0.enRCfg]
position = 9
name = "Enable RelaxCfg restore"
description = "Set this bit to enable RelaxCfg register to be restored after reset by the nRelaxCfg register. When this bit is clear, RelaxCfg restores with its alternate initialization value and nRelaxCfg can be used for general-purpose data storage."

[Registers.nNVCfg0.enLCfg]
position = 8
name = "Enable LearnCfg restore"
description = "Set this bit to enable LearnCfg register to be restored after reset by the nLearnCfg register. When this bit is clear, LearnCfg restores with its alternate initialization value and nLearnCfg can be used for general-purpose data storage."

[Registers.nNVCfg0.enICT]
position = 7
name = "Enable IChgTerm restore"
description = "Set this bit to enable IChgTerm register to be restored after reset by the nIChgTerm register. When this bit is clear, IChgTerm restores to a value of 1/3 C-rate (from FullCapNom) and nIChgTerm can be used for general-purpose data storage."

[Registers.nNVCfg0.enDP]
position = 6
name = "Enable Dynamic Power"
description = "Set this bit to enable Dynamic Power calculations. When this bit is set to 0, Dynamic Power calculations are disabled and registers MaxPeakPower/SusPeakPower/MPPCurrent/SPPCurrent can be used as general-purpose memory."

[Registers.nNVCfg0.enVE]
position = 5
name = "Enable VEmpty restore"
description = "Set this bit to enable VEmpty register to be restored after reset by the nVEmpty register. When this bit is clear, VEmpty restores with its alternate initialization value (3.0V) and nVEmpty can be used for generalpurpose data storage."

[Registers.nNVCfg0.enDC]
position = 4
name = "Enable DesignCap restore"
description = "Set this bit to enable DesignCap register to be restored after reset by the nDesignCap register. When this bit is clear, DesignCap restores with its alternate initialization value and nDesignCap can be used for general-purpose data storage."

[Registers.nNVCfg0.enMC]
position = 3
name = "Enable MiscCfg restore"
description = "Set this bit to enable MiscCfg register to be restored after reset by the nMiscCfg register. When this bit is clear, MiscCfg restores with its alternate initialization value and nMiscCfg can be used for generalpurpose data storage."

[Registers.nNVCfg0.enAF]
position = 2
name = "Enable Age Forecasting"
description = "Set this bit to enable Age Forecasting functionality. When this bit is clear, nAgeFcCfg can be used for general-purpose data storage. When set, nVoltTemp becomes repurposed for Age Forecasting data. When enAF is set to 1, nNVCfg2.enVT and nNVCfg2.enFL must be 0 for proper operation."

[Registers.nNVCfg0.SBSen2]
position = 1
name = "Enable SBS on DevName 420Ah or newer"
description = "This bit enables SBS functions of the IC with DevName 420Ah or newer. See the SBS section. When set, all registers accessed with the SBS 2-Wire address are regularly updated. When this bit and SBSen are clear, all SBS related nonvolatile configuration register locations can be used as general-purpose user memory. In addition, setting SBSen2 = 1 enables the bus timeout hardware required for proper SMBus support. If SBS2en = 1, set enSBS = 0."

[Registers.nNVCfg0.enSBS]
position = 0
name = "Enable SBS on DevName 4209h"
description = "This bit enables SBS functions of the IC with DevName 4209h. See the SBS section. When set, all registers accessed with the SBS 2-Wire address are regularly updated. When this bit and SBSen2 are clear, all SBS related nonvolatile configuration register locations can be used as general-purpose user memory. In addition, setting enSBS = 1 enables the bus timeout hardware required for proper SMBus support. If enSBS = 1, set SBSen2 = 0."

[Registers.nNVCfg1]
addr = 0x1B9
type = "special"
initial = 0x0182
description = "The nNVCfg1 register manages nonvolatile memory restore of device and fuel gauge register RAM locations. Each bit of the nNVCfg1 register, when set, enables a given register location to be restored from a corresponding nonvolatile memory location after reset of the IC. If nonvolatile backup of a given register is not enabled, that location initializes to a default value after reset instead. See the individual register descriptions for details."
zeros_mask = 0x9825

[Registers.nNVCfg1.enMtl]
position = 14
name = "Enable CGTempCo restore"
description = "Set this bit to enable CGTempCo register to be restored after reset by the nTCurve register. When this bit is clear CGTempCo restores with its alternate initialization value (copper). nTCurve can be used for general-purpose data storage if enMtl is clear."

[Registers.nNVCfg1.enFTh]
position = 13
name = "Enable FullSOCThr configuration restore"
description = "Set this bit to enable FullSOCThr register to be restored after reset by the nFullSOCThr register. When this bit is clear FullSOCThr restores with its alternate initialization value (80%) and nFullSOCThr can be used for general-purpose data storage."

[Registers.nNVCfg1.enJP]
position = 10
name = "Enable Protection with JEITA (temperature region dependent)"
description = "Set this bit to 1 to enable JEITA Protection. Clear this bit to disable JEITA protection and make OVP and OCCP thresholds become flat."

[Registers.nNVCfg1.enSC]
position = 9
name = "Enable special chemistry model"
description = "Set this bit to 1 if a special chemistry model is used. This bit enables the use of nScOcvLim."

[Registers.nNVCfg1.enProt]
position = 8
name = "Enable Protector"
description = "Set this bit to enable the protector. When this bit is clear, protector is disabled."

[Registers.nNVCfg1.enJ]
position = 7
name = "Enable ChargingCurrent and ChargingVoltage"
description = "Set this bit to 1 to enable ChargingCurrent and ChargingVoltage update feature."

[Registers.nNVCfg1.enProtChksm]
position = 6
name = "Enable ChargingCurrent and ChargingVoltage"
description = "Enable protector checksum function."

[Registers.nNVCfg1.enTTF]
position = 4
name = "Enable time-to-full configuration"
description = "Set to 1 to enable nTTFCfg (configures CVMixCap and CVHalftime) for tuning of Time-To-Full performance. Otherwise, CVMixCap and CVHalftime restore to their alternate initialization values and nTTFCfg can be used for general-purpose data storage."

[Registers.nNVCfg1.enAT]
position = 3
name = "Enable Alert Thresholds"
description = "Set this bit to enable IAlrtTh, VAlrtTh, TAlrtTh, and SAlrtTh registers to be restored after reset by the nIAlrtTh, nVAlrtTh, nTAlrtTh, and nSAlrtTh registers respectively. When this bit is clear these registers restore with their alternate initialization values and the nonvolatile locations can be used for general-purpose data storage."

[Registers.nNVCfg1.enCTE]
position = 1
name = "Enable Converge-to-Empty"
description = "Set this bit to enable the nConvgCfg register settings to affect the converge to empty functionality of the IC. When this bit is clear, converge-to-empty is disabled and nConvgCfg can be used for generalpurpose data storage."

[Registers.nNVCfg2]
addr = 0x1BA
type = "special"
initial = 0xBE2D
zeros_mask = 0x4140
description = "The nNVCfg2 register manages nonvolatile memory backup and restore of device and fuel gauge register RAM locations. Each bit of the nNVCfg2 register, when set, enables a given register location to be restored from or backed up to a corresponding nonvolatile memory location after reset of the IC. If nonvolatile backup of a given register is not enabled, that location initializes to a default value after reset instead. See the individual register descriptions for details."

[Registers.nNVCfg2.enT]
position = 15
name = "Enable TimerH backup and restore"
description = "Set this bit to enable TimerH register to be backed up and restored by the nTimerH register. When this bit is clear TimerH restores with its alternate initialization value and nTimerH can be used as general-purpose memory."

[Registers.nNVCfg2.enMMT]
position = 13
name = "Enable MaxMinTemp backup"
description = "Set this bit to enable storage of MaxMinTemp register information into the nMaxMinTemp register during save operations. EnMMT is incompatible with nNVCFG2.enFL. When enMMT and enFL bits are clear, nMaxMinTemp can be used as general-purpose memory."

[Registers.nNVCfg2.enMMV]
position = 12
name = "Enable MaxMinVolt backup"
description = "Set this bit to enable storage of MaxMinVolt register information into the nMaxMinVolt register during save operations. When this bit is clear nMaxMinVolt can be used as general-purpose memory."

[Registers.nNVCfg2.enMMC]
position = 11
name = "Enable MaxMinCurr backup"
description = "Set this bit to enable storage of MaxMinCurr register information into the nMaxMinCurr register during save operations. When this bit is clear nMaxMinCurr can be used as general-purpose memory."

[Registers.nNVCfg2.enVT]
position = 10
name = "Enable Voltage and Temperature backup"
description = "Set this bit to enable storage of AvgVCell and AvgTA register information into the nVoltTemp register during save operations. When this bit and nNVCfg0.enAF are clear nVoltTemp can be used as general-purpose memory. Note that enVT should not be set simultaneously with nNVCfg0.enAF (AgeForecasting) and nNVCfg2.enFL (Fault Logging)."

[Registers.nNVCfg2.enFC]
position = 9
name = "Enable FullCap and FullCapRep backup and restore"
description = "Set this bit to enable FullCap and FullCapRep registers to be restored after reset by the nFullCapRep register and FullCapRep to backup to nFullCapRep. When this bit is clear FullCap and FullCapRep registers restore from the nFullCapNom register. nFullCapRep can then be used as generalpurpose user memory."

[Registers.nNVCfg2.enMet]
position = 7
name = "Enable metal current sensing"
description = "Setting this bit to 1 enables temperature compensation of current readings for allowing copper trace current sensing. See also nNVCfg1.enMtl, which enables nTCurve register operation for adjustment of the current sensing temperature coefficient."

[Registers.nNVCfg2.enFL]
position = 5
name = "Enable Fault Logging"
description = "Set EnFL to store protector faults into nFaultLog.LowByte as shown in Table 48. EnFL is not compatible with Age Forecasting. nFaultLog can be used as general-purpose memory if not used for fault logging or age forecasting."

[Registers.nNVCfg2.FibMax]
msb = 4
lsb = 2
description = 'Set the FibMax and FibScl "Fibonacci Saving" interval to provide recurring log-saving according to the expected battery lifespan. See the 100 Record Life Logging section for more details.'

[Registers.nNVCfg2.FibScl]
msb = 1
lsb = 0
description = 'Set the FibMax and FibScl "Fibonacci Saving" interval to provide recurring log-saving according to the expected battery lifespan. See the 100 Record Life Logging section for more details.'

[Registers.nHibCfg]
addr = 0x1BB
initial = 0x0909
zeros_mask = 0x00E0
description = "The nHibCfg register controls hibernate mode functionality. The IC enters hibernate mode, if the measured system current falls below the HibThreshold setting for longer than the HibEnterTime delay. While in hibernate mode the IC reduces its operating current by slowing down its task period as defined by the HibScalar setting. The IC automatically returns to active mode of operation if current readings go above the HibThreshold setting for longer than the HibExitTime delay."

[Registers.nHibCfg.EnHib]
position = 15
name = "Enable Hibernate Mode"
description = "When set to 1, the IC enters hibernate mode if conditions are met. When set to 0, the IC always remains in active mode of operation."

[Registers.nHibCfg.HibEnterTime]
msb = 14
lsb = 12
description = "Sets the time period that consecutive current readings must remain below the HibThreshold value before the IC enters hibernate mode as defined by the following equation. The default HibEnterTime value of 000b causes the IC to enter hibernate mode if all current readings are below the HibThreshold for a period of 5.625 seconds, but the IC could enter hibernate mode as quickly as 2.812 seconds. 2.812s x 2(HibEnterTime) < Hibernate Mode Entry Time < 2.812s x 2(HibEnterTime + 1)"

[Registers.nHibCfg.HibThreshold]
msb = 11
lsb = 8
description = "Sets the threshold level for entering or exiting hibernate mode. The threshold is calculated as a fraction of the full capacity of the cell using the following equation: Hibernate Mode Threshold(mA) = (FullCap(mAh)/0.8hr)/2(HibThreshold)"

[Registers.nHibCfg.HibExitTime]
msb = 4
lsb = 3
description = "Sets the required time period of consecutive current readings above the HibThreshold value before the IC exits hibernate and returns to active mode of operation. Hibernate Mode Exit Time(s) = (HibExitTime + 1) x 702ms x 2(HibScalar)"

[Registers.nHibCfg.HibScalar]
msb = 2
lsb = 0
description = "Sets the task period while in hibernate mode based on the following equation: Hibernate Mode Task Period(s) = 702ms x 2(HibScalar)"

[Registers.nROMID0]
addr = 0x1BC
description = "Each IC contains a unique 64-bit identification value that is contained in the nROMID registers. Note this is the same ID that can be read using the 1-Wire ROM ID commands. nROMID3 is the most significant byte, nROMID0 is the least significant byte."

[Registers.nROMID1]
addr = 0x1BD
derived_from = "nROMID0"

[Registers.nROMID2]
addr = 0x1BE
derived_from = "nROMID0"

[Registers.nROMID3]
addr = 0x1BF
derived_from = "nROMID0"

[Registers.nPReserved0]
addr = 0x1C0
x_mask = 0xE3FF

[Registers.nPReserved0.UV_ChargeBlockThr]
msb = 12
lsb = 10
name = "UnderVoltage Charge Block threshold (DevName 420Ah or newer)"
description = "Enable this function to block charging if any of the cell voltages fall below this threshold. The UV_ChargeBlockThr can be set from 1.25V to 2.75V in steps of 0.25V. Set 000b to disable. UV_ChargeBlockThr Value(V) = 1V + (UV_ChargeBlockThr x .25V)"

[Registers.nChgCfg]
addr = 0x1C2
initial = 0x2061
zeros_mask = 0xC000
ones_mask = 0x2000
name = "Prequal Configuration"
description = """Configure the settings of prequal charging. Set nProtCfg.PreqEn to enable the prequal charging feature and nChgCtl (1C3h) = 00E1h for proper operation. The IC regulates the CHG gate voltage in order to control/limit the following:
- Charge Current
- CHG FET and DIS FET Temperature (using DieTemp)
When a charge source is applied, the charge FET is slowly turned on by the IC to allow the current to flow. It may take approximately 1 minute for the charge current to begin to flow when in prequal mode."""

[Registers.nChgCfg.PreQualVolt]
msb = 12
lsb = 8
signed = true
unit = "mV"
step = 20
name = "Prequal Voltage Offset"
description = "Sets the prequal voltage. Prequal Voltage = UVP + PreQualVolt x 20mV, PreQualVolt is a signed 2's compliment value with range of UVP – 320mV to UVP + 300mV."

[Registers.nChgCfg.HeatLim]
msb = 7
lsb = 5
description = "Set HeatLim to limit the thermal dissipation in the protection FETs during prequal regulation. Set HeatLim from 102mW to 819mW in 102mW steps. The effective power-dissipation limit is (HeatLim + 1) x 102mW."
zero_code_value = 102
step = 102
max = 816
unit = "mW"

[Registers.nChgCfg.PreChgCurr]
msb = 4
lsb = 0
description = "Sets the precharging current for the ChargingCurrent register. Precharge current is calculated as: PreChargeCurrent = nJEITAC.RoomChargingCurrent x (PreChgCurr + 1)/128 (range from RoomChargingCurrent/128 to RoomChargingCurrent/4)"

[Registers.nChgCtrl]
addr = 0x1C3
initial = 0x00E1

[Registers.nRGain]
addr = 0x1C4

[Registers.nPackResistance]
addr = 0x1C5

# TODO: initial of nFullSOCThr
[Registers.nFullSOCThr]
addr = 0x1C6
zeros_mask = 0x0002
ones_mask = 0x0005
restore = "FullSOCThr (013h) if nNVCfg1.enFT is set."
description = "The nFullSOCThr register gates detection of end-of-charge. VFSOC must be larger than the nFullSOCThr value before nIChgTerm is compared to the AvgCurrent register value. The recommended nFullSOCThr register setting for most custom characterized applications is 95% . For EZ performance applications, the recommendation is 80% (5005h). See the nIChgTerm register description and End-of-Charge Detection section for details."

[Registers.nFullSOCThr.nFullSOCThr]
msb = 15
lsb = 3
unit = "%"

# TODO: initial value of nTTFCfg
[Registers.nTTFCfg]
addr = 0x1C7
type = "special"
restore = "CVHalfTime (0B7h) and CVMixCapRatio (0B6h) if nNVCfg1.enTTF is set"
description = """The nTTFCfg register configures parameters related to the time-to-full (TTF) calculation. If nNVCfg1.enTTF is set, CVHalfTime (0B7h) and CVMixCapRatio (0B6h) are refreshed from the nTTFCfg Register. CVHalfTime (0B7h) is defined as the amount of time in the constant voltage portion of the charge cycle for the current to taper to half of the charging current in the constant current portion of the charge cycle. CVHalfTime has an LSB of 0.0001953125 hours.
CVMixCapRatio (0B6h) is defined as the approximate state of charge where the charge transitions from the constant current portion of the charge cycle to the constant voltage portion of the charge current. CVMixCapRatio has an LSB of 0.5mAh.
The Alternate Initial Value indicates that the charge cycle transitions from constant current to constant voltage when the SOC is 75% and that it then takes 30 minutes for the current to taper half of the charging current. 
For example, for a nCVHalftime of 37.5 minutes (2250 seconds) and a nCVMixRatio of 59%, the value for nTTFCfg = 3297h. These values are calculated as follows:
nCVHalfTime = 2250s/45 = 50dec = 32h
nCVMixCapRatio = 59% x 256 = 151dec = 97h 
"""

[Registers.nTTFCfg.nCVMixCapRatio]
msb = 15
lsb = 8
description = "nCVHalfTime has an LSB of 45 seconds giving a full scale range of 0 seconds to 192 minutes. nCVHalfTime = CVHalfTime(s)/45 seconds"
unit = "s"
step = 45

[Registers.nTTFCfg.nCVHalfTime]
msb = 7
lsb = 0
description = "nCVMixCapRatio has an LSB of 1/256 giving a full scale range of 0 to 0.9961. nCVMixCapRatio = CVMixCapRatio(%) × 256 "
step = 0.00390625

[Registers.nCGain]
addr = 0x1C8
initial = 0x4000
description = "The nCGain register adjusts the gain and offset of the current measurement result. The current measurement ADC is factory trimmed to data-sheet accuracy without the need for the user to make further adjustments. The recommended default for the nCGain register is 0x4000 which applies no adjustments to the Current register reading. For specific application requirements, the CGain and COff values can be used to adjust readings as follows: Current Register = (Current ADC Reading × (CGain/256)) + COff"

[Registers.nCGain.CGain]
msb = 15
lsb = 6
signed = true
description = "The recommended default value of CGain = 0x100 corresponds to a gain of 1. CGain can be calculated as follows: CGain = ((MeasuredCurrent/ReportedCurrent) × 0x0100). CGain is a signed value and can be negative."

[Registers.nCGain.COff]
msb = 5
lsb = 0
signed = true
description = "COff has a range of -32 to +31 LSbs. However, it is normally not recommended to calibrate COff. COff = 0 is recommended for most applications."

[Registers.nCGTempCo]
addr = 0x1C9
derived_from = "CGTempCo"

[Registers.nThermCfg]
addr = 0x1CA
initial = 0x71BE
description = """External NTC thermistors generate a temperature related voltage measured at the TH(1-4) pins. Set nThermCfg register to compensate thermistor for accurate translation of temperature.
For 10k: nThermCfg = 7000h + (3245919/Beta - 512)
For 100k: nThermCfg = 3000h + (3245919/Beta - 512)
Use Beta 25°C-85°C.
"""

# TODO: check order of characters in nManfctrName
[Registers.nManfctrName0]
addr = 0x1CC
description = "First two characters of the manufacturer name"

[Registers.nManfctrName1]
addr = 0x1CD
description = "3rd and 4th character of the manufacturer name"

[Registers.nManfctrName2]
description = "5th and 6th character of the manufacturer name"
addr = 0x1CE

[Registers.nRSense]
addr = 0x1CF
type = "special"
initial = 0x01F4
description = "The nRSense register is the designated location to store the nominal sense resistor value used by the application. This value is not used by the IC as all current and capacity information is reported in terms of μV and μVH. Host software can use the nRSense register value to convert current and capacity information into mA and mAH.  It is recommended that the sense resistor value be stored with an LSb weight of 10μΩ giving a range of 10μΩ to 655.35mΩ"

[Registers.nUVPrtTh]
addr = 0x1D0
initial = 0x508C
zeros_mask = 0x0200
description = "Sets undervoltage protection, deep-discharge-state protection, and undervoltage-shutdown thresholds."
msb = 15
lsb = 10

[Registers.nUVPrtTh.UVP]
name = "UnderVoltage Protection threshold"
description = "The IC opens the discharge FET when VCell < UVP. UVP can be configured from 2.2V to 3.46V in 20mV steps."
msb = 15
lsb = 10
zero_code_value = 2.2
ax = 3.46
step = 0.02
unit = "V"

[Registers.nUVPrtTh.UOCVP]
name = "Under Open Circuit Voltage Protection Threshold (also refered to as SmartEmpty)"
description = "The IC opens the discharge FET when VFOCV < UOCVP. UOCVP is relative to UVP and can be configured from UVP to UVP + 1.28V in 40mV steps."
msb = 8
lsb = 4
step = 40
unit = "mV"

[Registers.nUVPrtTh.UVShdn]
name = "UnderVoltage Shutdown Threshold"
description = "The IC shutdowns when VCell < UVShdn. UVShdn is relative to UVP and can be configured from UVP - 0.32V to UVP + 0.28V in 40mV steps."
msb = 3
lsb = 0
signed = true
unit = "mV"
step = 40

# TODO: check what unit T1-T4 have
[Registers.nTPrtTh1]
addr = 0x1D1
description = 'Sets T1 "Too-Cold" and T4 "Too-Hot" thresholds which control JEITA and provide charging (Too-Hot or Too-Cold) protection. nProtMiscTh.TooHotDischarge provides discharging (Too-Hot only) protection.'
initial = 0x3700

[Registers.nTPrtTh1.T4]
msb = 15
lsb = 8
description = 'JEITA "Too-Hot" temperature threshold. When Temp > T4, charging is blocked by the IC.'

[Registers.nTPrtTh1.T1]
msb = 7
lsb = 0
description = 'JEITA "Too-Cold" temperature threshold. When Temp < T1, charging is considered unsafe and unhealthy, and the IC blocks charging.'

[Registers.nTPrtTh3]
addr = 0x1D2
initial = 0x5528
description = "Sets Twarm and TpermFailHot thresholds which control JEITA and modulate charging (Warm) guidance and protection. nTPrtTh3 defines protection thresholds beyond standard JEITA definition."

[Registers.nTPrtTh3.TpermFailHot]
msb = 15
lsb = 8
description = "If enabled, the IC goes into permanent failure mode, and permanently disables the charge FET as well as trips the secondary protector (if installed) or blows the fuse (if installed)."

[Registers.nTPrtTh3.Twarm]
msb = 7
lsb = 0
description = "Warm temperature threshold (between 'normal' and THot), giving an extra temperature region for changing charging current and charging voltage control."

[Registers.nIPrtTh1]
addr = 0x1D3
initial = 0x4BB5
description = "sets upper and lower limits for overcurrent protection when current exceeds the configuration threshold. The upper 8-bits set the overcharge current-protection threshold and the lower 8-bits set the overdischarge current-protection threshold. Protection threshold limits are configurable with 400μV resolution over the full operating range of the current register."

[Registers.nIPrtTh1.OCCP]
msb = 15
lsb = 8
signed = true
name = "Overcharge Current-Protection Threshold at Room Temperature"
description = """Overcharge current-protection occurs when the current register reading exceeds this value. This field is signed 2's complement with 400μV LSb resolution to match the upper byte of the current register. HotCOEF, WarmCOEF, and ColdCOEF re-scales nIPrtTh1.OCCP in hot, warm, and cold zone.
For example, in warm zone, overcharge current-protection threshold updates to OCCP x WarmCOEF.
See the nJEITAC register for HotCOEF, WarmCOEF, and ColdCOEF definitions and the nTPrtTh2 and nTPrtTh3
registers for temperature zone definitions."""
unit = "μV"
step = 400

[Registers.nIPrtTh1.ODCP]
msb = 7
lsb = 0
signed = true
name = "Overdischarge Current-Protection Threshold"
description = """Overdischarge current-protection occurs when current register reading exceeds this value. This field is signed 2's complement with 400μV LSb resolution to match the upper byte of the current register.
The fault delay for OCCP and ODCP is configured in nDelayCfg.OverCurrTimer."""
unit = "μV"
step = 400

[Registers.nBALTh]
addr = 0x1D4
description = "Sets the balancing and imbalance settings and thresholds."
zeros_mask = 0xC000

[Registers.nBALTh.Zener]
position = 13
name = "Zener Balancing Enable"
description = "Set to 1 to enable the Zener Balancing functionality. Set to 0 to disable the Zener Balancing. When Zener Balancing is enabled, the IC acts as if a Zener diode is placed in parallel with each cell. The reverse breakdown voltage of the virtual Zener diode is the ChargingVoltage register. Whenever nBalTh.Zener = 1, the IC enables an internal FET to shunt current away from the highest voltage cell with a voltage higher than the ChargingVoltage register."

[Registers.nBALTh.BALCFG]
msb = 12
lsb = 10
name = "Balancing Configuration"
description = "This field sets the cell balancing voltage threshold. When set to 0, cell balancing is disabled. When BALCFG bits are set to any nonzero value, cell balancing begins when inside the cell balancing window as shown in Figure 23. See RMismatch section for details."

[Registers.nBALTh.Rmismatch]
msb = 9
lsb = 5
name = "Balancing Configuration"
description = "Rmismatch is set according to the following equation: nBalTh.Rmismatch = 32 x Rmismatch(mΩ)/125mΩ (maximum settable Rmismatch is 121mΩ). Choose Rmismatch in mΩ approximately 20% of nominal battery resistance. The default recommendation is nBalTh.Rmismatch = 3 corresponding with 11.7mΩ. See the RMismatch section for details."

[Registers.nBALTh.Imbalance]
msb = 4
lsb = 0
name = "Cell Imbalance Protection Threshold"
description = "Set the amount of cell imbalance that creates a charge protection fault. Set Imbalance to 0 to disable cell imbalance protection. The LSB size is 10mV."
unit = "mV"
step = 10

[Registers.nTPrtTh2]
addr = 0x1D5
initial = 0x2D0A
description = 'Sets T2 "Cold" and T3 "Hot" thresholds which control JEITA and modulate charging (Hot or Cold) guidance and protection.'

[Registers.nTPrtTh2.T3]
msb = 15
lsb = 8
description = 'JEITA "JEITA "Hot" temperature threshold. When Temp > T3, charging current/voltage should be reduced and the chargeprotection thresholds are adjusted accordingly.'

[Registers.nTPrtTh2.T2]
msb = 7
lsb = 0
description = 'JEITA "Cold" temperature threshold. When Temp < T2, charging current/voltage should be reduced, and the chargeprotection thresholds are adjusted accordingly.'

[Registers.nProtMiscTh]
addr = 0x1D6
initial = 0x7A28
description = "Sets a few miscellaneous protection thresholds. "

[Registers.nProtMiscTh.QovflwTh]
msb = 15
lsb = 12
name = "Capacity Overflow Threshold"
description = "QovflwTh sets the coefficient for the capacity overflow-protection threshold. Capacity overflow protection threshold = designCap x coefficient. The IC monitors the delta coulomb count (deltaQ) between the coulomb count at the start-of-charge and the present coulomb count. If the delta Q exceeds the capacity overflow-protection threshold, indicating that the charger has charged more than the expected capacity of the battery, then a ProtStatus.Qovrflw fault is generated. The coefficient is calculated as: coefficient = 1.0625 + (QovflwTh x 0.0625)."

[Registers.nProtMiscTh.TooHotDischarge]
msb = 11
lsb = 8
name = "Capacity Overflow Threshold"
description = "Sets the Overtemperature-Protection Threshold Associated with Discharge. TooHotDischarge has 2°C LSB's and defines the delta between Over-Temp-Charge (nTPrtTh1.T4) and Over-Temp-Discharge. The range is nTPrtTh1.T4(TooHot) to nTPrtTh1.T4(TooHot) + 30°C."

[Registers.nProtMiscTh.CurrDet]
msb = 7
lsb = 4
description = "CurrDet is configurable from 25μV/RSENSE to 400μV/RSENSE in 25μV/RSENSE steps (equivalent to 5mA to 80mA in 5mA steps with a 5mΩ sense resistor). It is a threshold to detect discharging and charging events. If current > CurrDet then charging; if current < -CurrDet then discharging. CurrDet Threshold = (CurrDet + 1) x 5mA (i.e., 0 = 5mA for 5mΩ RSENSE)"

[Registers.nProtMiscTh.DieTempTh]
msb = 3
lsb = 0
description = "Sets the Dietemp Overtemperature-Protection Threshold. DieTempTh is used as a proxy for FET temperature and controls the FET overtemperature fault. The range is 50°C and 125°C with a 5°C LSB."
zero_code_value = 50
step = 5
unit = "°C"

[Registers.nProtCfg]
addr = 0x1D7
initial = 0x0900
zeros_mask = 0x6200
description = "The Protection Configuration register contains enable bits for various protection functions."

[Registers.nProtCfg.ChgWDTEn]
position = 15
name = "Charger WatchDog Enable"
description = "If the charger watchdog feature is enabled, the protector disallows charging unless communication has not been detected for more than the Charger WatchDog delay that is configured innDelayCfg.ChgWdg."

[Registers.nProtCfg.SCTest]
msb = 12
lsb = 11
description = 'Set SCTest = 01b to source 30μA from BATT to PCKP for testing the presence/removal of any overload/shortcircuit at PCKP. SCTest is only used during special circumstances when DIS = off. Particularly if an overdischarge current fault has been tripped. The IC sets SCTest to push 30μA into PCKP. If PCKP rises above the 1.5V SCDet threshold, then the overload is considered "removed" and safe to reconnect the DIS FET. Because of this, the PCKP resistor must be 10kΩ or less for proper short-circuit removal detection. Set SCTest = 00b to disable.'

[Registers.nProtCfg.CmOvrdEn]
position = 10
name = "Comm Override Enable"
description = "This bit when set to 1, allows the ChgOff and DisOff bits in CommStat to be set by I2C/1Wire communication to turn off the protection FETs."

[Registers.nProtCfg.PreqEn]
position = 8
name = "PreQual Enable"
description = "Set PreqEn = 1 to enable the Pre-Qual enable functionality."

[Registers.nProtCfg.PFEn]
position = 6
name = "PermFail Enable"
description = "Set PFEn = 1 to enable the detection of a Permanent Failure to permanently turn the FETs off. All types of permanent failures operate only if PFEn = 1 and are all disabled if PFEn = 0. PFEn must be enabled for the PFAIL pin to be operational. See the Permanent Fail section for more details."

[Registers.nProtCfg.DeepShpEn]
position = 5
name = "Deepship Enable"
description = "Set DeepShpEn = 1 to associate shutdown actions (I2C shutdown command or communication removal) with 2.2μA shutdown. All registers power down in this mode. Set DeepShpEn = 0 to continue full calculations but with protector disabled (CHGEn = 0, DISEn = 0, pump off), operating at 6μA consumption."

[Registers.nProtCfg.OvrdEn]
position = 4
name = "Override Enable"
description = "Set OvrdEn = 1 to enable the Alert pin to be an input to turn disable the protection FETs."

[Registers.nProtCfg.UVRdyn]
position = 3
name = "Undervoltage-Ready"
description = "In the undervoltage-protected state (but higher than undervoltage shutdown), this bit chooses whether or not the CHG FET remains enabled. Configure UVRdy = 0 to keep the CHG FET and corresponding pumps powered during undervoltage protection. In this state, the pack is quickly responsive to charger connection, but the quiescent consumption remains 38μA. Configure UVRdy = 1 to disable the CHG FET and corresponding charge pumps during undervoltage protection. In this state, the consumption drops to 16μA, but there may be hibernate latency between when the charger is applied and the battery begins charging."

[Registers.nProtCfg.FetPFEn]
position = 2
name = "FET PermFail Enable"
description = "Set to 1 to enable Charge FET and Discharge FET open or short failure detection, which registers a permanent failure and permanently turn the FETs off and drive the PFAIL pin high. PFEn must also be set for the FET PermFail Enable to operate."

[Registers.nProtCfg.BlockDisCEn]
position = 1
name = "Block Discharge at TooCold Enable"
description = "If the block discharge at cold is enabled, the protector also disallows discharging when the temperature is below the TooCold Threshold (nTPrtTh1) (DevName 420Ah only)."

[Registers.nJEITAC]
addr = 0x1D8
initial = 0x644B
description = "Sets the nominal room temperature charging current and the coefficients to scale the charging current across the temperature zones shown in Figure 3. The WarmCOEF, ColdCOEF, and HotCOEF coefficients impact the charging current as well as OCCP and ODCP (See nIPrtTh1). To disable the temperature dependence and create a flat charging current across the temperature range, set the lower byte of nJEITAC to a value of FFh."

[Registers.nJEITAC.RoomChargingCurrent]
msb = 15
lsb = 8
description = "Sets the nominal room-temperature charging current. The LSB is 200μV. This value is unsigned with a range of 00h (0mV) to FFh (51.2mV)."
unit = "μV"
step = 200

[Registers.nJEITAC.WarmCOEF]
msb = 7
lsb = 6
description = "Coefficient 62.5% to 100% relative to ChargingCurrent for controlling the charge current at warm. WarmCOEF has a 12.5% LSB resolution. The resulting WarmChargingCurrent is controlled by the following equation: WarmChargingCurrent = RoomChargingCurrent x (WarmCOEF+5)/8"
unit = "%"
step = 12.5
zero_code_value = 62.5

[Registers.nJEITAC.ColdCOEF]
msb = 5
lsb = 3
description = "Coefficient 12.5% to 100% relative to ChargingCurrent for controlling the charge current at cold. ColdCOEF has a 12.5% LSB resolution. The resulting ColdChargingCurrent is controlled by the following equation: ColdChargingCurrent = RoomChargingCurrent x (ColdCOEF+1)/8"
unit = "%"
step = 12.5
zero_code_value = 12.5

[Registers.nJEITAC.HotCOEF]
msb = 2
lsb = 0
description = "Coefficient 12.5% to 100% relative to ChargingCurrent for controlling the charge current at hot. HotCOEF has a 12.5% LSB resolution. The resulting HotChargingCurrent is controlled by the following equation: HotChargingCurrent = RoomChargingCurrent x (HotCOEF+1)/8"
unit = "%"
step = 12.5
zero_code_value = 12.5

[Registers.nJEITAV]
addr = 0x1D9
initial = 0x0059
description = "Sets the JEITA Charge Voltage configuration for the IC. The JEITA charge voltage can be read from a charger to set the appropriate charge voltage based on the temperature. Also, this value is used to determine the overvoltage-protection threshold. Each charge voltage register is an offset with a 5 or 20mV resolution. The RoomChargeV offset is defined relative to a normal standard charge setting of 4.2V. The additional charge voltages are relative to RoomChargeV based on the temperature. To disable the temperature dependence and create a flat charging voltage across the temperature range, set dWarmChargeV, dColdChargeV, and dHotChargeV to a value of 00b."

[Registers.nJEITAV.RoomChargeV]
msb = 15
lsb = 8
description = 'RoomChargeV defines the charge voltage between temperatures T2 "Cold" and T3 "Warm", relative to a standard 4.2V setting, providing a range of 3.56V to 4.835V in 5mV steps. RoomChargeV is a signed configuration. Set to 00h to configure for standard 4.2V.'
signed = true
unit = "mV"
step = 5
zero_code_value = 4200

[Registers.nJEITAV.dWarmChargeV]
msb = 7
lsb = 6
description = "WarmChargeV defines the delta charge voltage (relative to RoomChargeV) between temperatures TWarm and T3, relative to the room setting, providing a range of RoomChargeV to (RoomChargeV-60mV) in -20mV steps. dWarmChargeV configuration is unsigned."
unit = "mV"
step = -20

[Registers.nJEITAV.dColdChargeV]
msb = 5
lsb = 3
description = "ColdChargeV defines the delta charge voltage (relative to RoomChargeV) between temperatures T1 and T2, relative to the room setting, providing a range of RoomChargeV to (RoomChargeV-140mV) in -20mV steps. dColdChargeV configuration is unsigned."
unit = "mV"
step = -20

[Registers.nJEITAV.dHotChargeV]
msb = 2
lsb = 0
description = "HotChargeV defines the delta charge voltage (relative to WarmChargeV) between temperatures T3 and T4, relative to the room setting, providing a range of WarmChargeV to (WarmChargeV-140mV) in -20mV steps. dHotChargeV configuration is unsigned."
unit = "mV"
step = -20

[Registers.nOVPrtTh]
addr = 0x1DA
initial = 0xB754
description = "Sets the permanent overvoltage protection threshold, the charge-detection threshold, the overvoltage-protection threshold, and the overvoltage-protection-release threshold. dOVP and dOVPR are relative to the Charge Voltage that is set in the nJEITAV register and have a 10mV resolution."

[Registers.nOVPrtTh.OVPPermFail]
msb = 15
lsb = 12
name = "Permanent Failure OVP (permanent overvoltage protection) Threshold"
description = "Permanent failure overvoltage protection occurs when any cell voltage register reading exceeds this value. The OVPPermFail range is OVP_thresholdRoom + 40mV to OVP_thresholdRoom + 340mV with a 20 mV lsb. OVP_PermFail_Threshold = OVPRoom + 40mV + (OVPPermFail x 20mV)"
unit = "mV"
zero_code_value = 40
step = 20

[Registers.nOVPrtTh.ChgDetTh]
msb = 10
lsb = 8
name = "Charger Detection Threshold"
description = "The IC determines that a charger is connected when PCKP > (BATT + ChgDetTh). ChgDetTh has a range of 10mV to 80mV with a 10mV lsb."
unit = "mV"
zero_code_value = 10
step = 10

[Registers.nOVPrtTh.dOVP]
msb = 7
lsb = 4
name = "Delta from ChargeVoltage to Overvoltage Protection"
description = "dOVP sets JEITA overvoltage protection relative to ChargeVoltage (see nJEITAV). If nNVCfg1.enJP is disabled, then OVP voltage is calculated from RoomChargeV across all temperature zones. This is a positive number with 10mV resolution and 150mV range. Overvoltage protection is calculated as: OVP = ChargeVoltage + dOVP x 10mV"
unit = "mV"
step = 10

[Registers.nOVPrtTh.dOVPR]
msb = 3
lsb = 0
name = "Delta from Overvoltage Protection to the Overvoltage-Release Threshold"
description = "dOVPR sets overvoltage-protection release relative to the overvoltage-protection setting. This is a positive number with 10mV resolution and is translated to a negative offset relative to OVP. Overvoltage-protection release is calculated as: OVPR = OVP - dOVPR x 10mV"
unit = "mV"
step = 10

[Registers.nStepChg]
addr = 0x1DB
initial = 0xC884
description = """The nStepChg register defines the step-charging prescription as shown in Figure 10.
Note: This only effects the ChargingCurrent output register which prescribes a charge current controlled by the external charger. To disable step-charging prescription, set nStepChg = FF00h."""

[Registers.nStepChg.StepCurr1]
msb = 15
lsb = 12
description = "Scales the JEITA zone charge current down by a 4-bit ratio from 1/16 to 16/16. StepCurrent1 = ChargingCurrent_JEITAZONE x StepCurr1/16."
unit = "%"
step = 6.25
zero_code_value = 6.25

[Registers.nStepChg.StepCurr2]
msb = 11
lsb = 8
description = "Scales the JEITA zone charge current down by a 4-bit ratio from 1/16 to 16/16. StepCurrent2 = ChargingCurrent_JEITAZONE x StepCurr2/16."
unit = "%"
step = 6.25
zero_code_value = 6.25

[Registers.nStepChg.StepdV0]
msb = 7
lsb = 4
description = "These register bit-fields configure StepVolt0 and StepVolt1 relative to the JEITA zone charge voltage. Both registers are negative offsets relative to JEITA ChargeVoltage, and both registers support 10mV LSB. StepV0 = ChargingVoltageJEITAZONE - (StepdV0 x 10mV)."
unit = "mV"
step = -10

[Registers.nStepChg.StepdV1]
msb = 3
lsb = 0
description = "These register bit-fields configure StepVolt0 and StepVolt1 relative to the JEITA zone charge voltage. Both registers are negative offsets relative to JEITA ChargeVoltage, and both registers support 10mV LSB. StepV1 = ChargingVoltageJEITAZONE - (StepdV1 x 10mV)."
unit = "mV"
step = -10

[Registers.nDelayCfg]
addr = 0x1DC
initial = 0xAB3D
description = "Set nDelayCfg to configure debounce timers for various protection faults. A fault state is concluded only if the condition persists throughout the duration of the timer. All delay times start when the ADC first measures the value to exceed the protection threshold which could be up to an additional 351ms of delay between the time the fault is observed externally and the time the ADC first measures the fault."

[Registers.nDelayCfg.CHGWDT]
msb = 15
lsb = 14
description = "Set CHGWDT to configure the charger communication watchdog timer. If enabled, the IC charge-protects whenever the host has stopped communicating longer than this timeout."

[Registers.nDelayCfg.CHGWDT.values]
0 = "11.2s to 22.5s"
1 = "22.5s to 45s"
2 = "45s to 90s"
3 = "90s to 3min"

[Registers.nDelayCfg.PrequalTimer]
msb = 13
lsb = 11
description = "Set Prequal Timer to configure the timing for prequal charging."

[Registers.nDelayCfg.PrequalTimer.values]
0 = "16.875s to 22.5s"
1 = "33s to 44s"
2 = "67s to 90s"
3 = "2.25min to 3min"
4 = "4.5min to 6min"
5 = "9min to 12min"
6 = "18min to 24min"
7 = "36min to 48min"

[Registers.nDelayCfg.OVPTimer]
msb = 10
lsb = 9
description = "Set OVPTimer to configure the fault timing for Overvoltage-Protection."

[Registers.nDelayCfg.OVPTimer.values]
0 = "0 to 351ms"
1 = "2.8s to 5.625s"
2 = "5.625s to 11.25s"
3 = "11.25s to 22.5s"

[Registers.nDelayCfg.OverCurrTimer]
msb = 8
lsb = 6
description = "OverCurrTimer configures the fault timing for the slow overcharge-current detection (OCCP) as well as overdischarge-current detection (ODCP). The additional fast hardware protection thresholds are described in nODSCCfg and nODSCTh."

[Registers.nDelayCfg.OverCurrTimer.values]
0 = "0-351ms"
1 = "0.351s to 0.7s"
2 = "0.7s to 1.4s"
3 = "1.4s to 2.8s"
4 = "2.8s to 5.6s"
5 = "5.6s to 11.25s"
6 = "11.25s to 22.5s"
7 = "22.5s to 45s"

[Registers.nDelayCfg.PermFailTimer]
msb = 5
lsb = 4
description = "Set PermFailTimer to configure the fault-timing for permanent failure detection. PermFailTimer must be set to 3 for permanent failure detection to function properly."

[Registers.nDelayCfg.PermFailTimer.values]
0 = "0 to 351ms"
1 = "351ms to 0.7s"
2 = "0.7s to 1.4s"
3 = "1.4s to 2.8s"

[Registers.nDelayCfg.TempTimer]
msb = 3
lsb = 2
description = "Set TempTimer to configure the fault-timing for the following faults: Too-Cold-Charging (TooColdC), TooHot-Charging (TooHotC), Die-Hot (DieHot), and Too-Hot-Discharging (TooHotD). The TempTimer setting also controls the temperature transition delay. If the IC detects a change in temperature zone that results in the OVP level being reduced to a lower level due to the JEITA configuration. There is a delay equal to the TempTrans Configuration before the new lower OVP threshold goes into effect."

[Registers.nDelayCfg.TempTimer.values]
0 = "0 to 351ms"
1 = "1.4s to 2.8s"
2 = "2.8s to 5.625s"
3 = "5.625s to 11.25s"

[Registers.nDelayCfg.TempTimer.variants.Application.values]
0 = "No Debouncing"
1 = "Debounce 1 Thermistor"
2 = "Debounce up to 2 Thermistors"
3 = "Debounce up to 4 Thermistors"

[Registers.nDelayCfg.TempTimer.variants.TempTrans.values]
0 = "3.151s to 4.55s"
1 = "5.951s to 8.75s"
2 = "11.55s to 17.15s"
3 = "23.351s to 34.851s"

[Registers.nDelayCfg.UVPTimer]
msb = 1
lsb = 0
description = "Set UVPTimer to configure the Undervoltage-Protection timer. "

[Registers.nDelayCfg.UVPTimer.values]
0 = "0 to 351ms"
1 = "2.8s to 5.625s"
2 = "5.625s to 11.25s"
3 = "11.25s to 22.5s"

[Registers.nDelayCfg.UVPTimer.variants.ShutdownTimer]
description = "Set UVPTimer to configure the Shutdown timer."

[Registers.nDelayCfg.UVPTimer.variants.ShutdownTimer.values]
0 = "22.5s to 45s"
1 = "45s to 90s"
2 = "90s to 180s"
3 = "3min to 6min"

[Registers.nODSCTh]
addr = 0x1DD
initial = 0x0EAF
x_mask = 0x8000
description = "The nODSCTh register sets the current thresholds for each overcurrent alert."

[Registers.nODSCTh.OCTH]
msb = 14
lsb = 10
name = "Overcharge Threshold Setting"
description = "Sets the overcharge threshold to a value between 0mV and 38.75mV with a step size of 1.25mV. The OCTH bits are stored such that 1Fh = 0mV and 00h = 38.75mV. Overcharge threshold is calculated as 38.75mV - (OCTH x 1.25mV))."
unit = "mV"
step = -1.25
zero_code_value = 38.75

[Registers.nODSCTh.SCTH]
msb = 9
lsb = 5
name = "Short-Circuit Threshold Setting"
description = "Sets the short-circuit threshold to a value between 0mV and -155mV with a step size of -5mV. The SCTH bits are stored such that 1Fh = 0mV and 00h = -155mV. Short-circuit threshold is calculated as -155mV + (SCTH x 5mV))."
unit = "mV"
step = 5
zero_code_value = -155

[Registers.nODSCTh.ODTH]
msb = 4
lsb = 0
name = "Overdischarge Threshold Setting"
description = "Sets the overdischarge threshold to a value between 0mV and -77.5mV with a step size of -2.5mV. The ODTH bits are stored such that 1Fh = 0mV and 00h = -77.5mV. Overdischarge threshold is calculated as -77.5mV + (ODTH x 2.5mV))."
unit = "mV"
step = 2.5
zero_code_value = -77.5

[Registers.nODSCCfg]
addr = 0x1DE
initial = 0x4355
x_mask = 0xB0A0
ones_mask = 0x4050

[Registers.nODSCCfg.SCDlY]
msb = 11
lsb = 8
name = "Short-Circuit Delay"
description = "Configure from 0h to Fh to set short circuit detection debouncing delay between 70μs and 985μs (70μs + 61μs x SCDLY). There may be up to 31μs of additional delay before the short-circuit's alert affects the discharge FET."
unit = "μs"
step = 61
zero_code_value = 70

[Registers.nODSCCfg.OCDlY]
msb = 3
lsb = 0
name = "Overdischarge and Overcharge Current Delay"
description = "Configure from 1h to Fh to set overdischarge/overcharge detection debouncing delay between 70μs and 14.66ms (70μs + 977μs x OCDLY)."
unit = "μs"
step = 977
zero_code_value = 70

[Registers.nProtCfg2]
addr = 0x1DF
initial = 0xA065
ones_mask = 0x8000
zeros_mask = 0x5000
description = "See Battery Internal Self-Discharge Detection Registers"

[Registers.nProtCfg2.CEEn]
position = 13
name = "Coulombic-efficiency (CE) method enable"
description = "Set to 1 to enable self-discharge detection."

[Registers.nProtCfg2.LeakCurrTh]
msb = 11
lsb = 8
name = "Leakage Current Threshold"
description = "An unsigned 4-bit threshold for leakage current alert and fault generation. The LSB resolution is either 0.625mA or 1.25mA based on the LeakCurrCfg setting as shown in Table 42. When alerts and faults are both enabled, the fault threshold is either 5mA, 10mA or 20mA above the alert threshold as shown in the Description column of Table 42."

[Registers.nProtCfg2.CheckSum]
msb = 7
lsb = 0
name = " Protector NVM CheckSum."
description = "CheckSum is the checksum value of the protection registers for validating NVM at startup when nNVCfg1.enProtChksm = 1."

[Registers.nDPLimit]
addr = 0x1E0

[Registers.nScOcvLim]
addr = 0x1E1

[Registers.nAgeFcCfg]
addr = 0x1E2
type = "special"
ones_mask = 0x0003
zeros_mask = 0x001C
description = "The nAgeFcCfg register is used to configure the age forecasting functionality. Register data is nonvolatile and is typically configured only once during pack assembly."

[Registers.nAgeFcCfg.DeadTargetRatio]
msb = 15
lsb = 12
description = "Sets the remaining percentage of initial cell capacity where the cell is considered fully aged. DeadTargetRatio can be adjusted between 75% and 86.72% with an LSb of 0.7813%. For example, if age forecasting was configured to estimate the number of cycles until the cell’s capacity dropped to 85.1574% of when it was new, DeadTargetRatio should be programmed to 1101b."
unit = "%"
zero_code_value = 75
step = 0.7813

[Registers.nAgeFcCfg.CycleStart]
msb = 11
lsb = 5
description = "Sets the number of cell cycles before age forecasting calculations begin. CycleStart has a range of 0.00 to 81.92 cycles with an LSb of 0.64 cycles. Since age forecasting estimation becomes more accurate over time, most applications use a default value of 30 cycles."
unit = "cycles"
step = 0.64

[Registers.nDesignVoltage]
addr = 0x1E3
initial = 0xA5B9

[Registers.nDesignVoltage.Vminsys]
msb = 15
lsb = 8
name = "Minimum system voltage"
description = "'Minimum system voltage' specification for the design. Generates MinSysVoltage value. This value is used in SBS calculations only when enSBS = 1."
step = 20
unit = "mV"

[Registers.nDesignVoltage.Vdesign]
msb = 7
lsb = 0
name = "Design voltage"
description = "'Design voltage' specification for the design. This value is used in SBS calculations only when enSBS = 1."
step = 20
unit = "mV"

[Registers.nManfctrDate]
addr = 0x1E6
name = "Manufacture Date"
description = "Manufacture Date in SBS V1.1 format."

[Registers.nManfctrDate.Year]
msb = 15
lsb = 9
zero_code_value = 1980

[Registers.nManfctrDate.Month]
msb = 8
lsb = 5
max = 12
min = 1

[Registers.nManfctrDate.Day]
msb = 4
lsb = 0
max = 31
min = 1

[Registers.nFirstUsed]
addr = 0x1E7

[Registers.nSerialNumber0]
addr = 0x1E8
description = "SerialNumber indicates the 16-bit serial number as stored in nSerialNumber MTP. SerialNumber2 and SerialNumber3 provide extended data for the serial number as stored in nSerialNumber2 and nSerialNumber3. By using 6 bytes total, a serial number can provide a very unique ID for 281 trillion devices. A 4-byte serial number can support 4.3 billion devices. Some of the bits can be fixed to indicate platform or other information."

[Registers.nSerialNumber1]
addr = 0x1E9
derived_from = "nSerialNumber0"

[Registers.nSerialNumber2]
addr = 0x1EA
derived_from = "nSerialNumber0"

[Registers.nDeviceName0]
addr = 0x1EB
description = "A block SMBus/I2C read of 0x21 on the I2C slave 0x16 (SBS) reports RAM address 0x121 sequenced with 0x140 to 0x143, for a total of 5 words of data. The first byte indicates the byte length and the following bytes are ASCII characters representing the device name. This data is taken from nDeviceName in NVM, except that the byte count is set by firmware instead of saved in NVM."

[Registers.nDeviceName1]
addr = 0x1EC
derived_from = "nDeviceName0"

[Registers.nDeviceName2]
addr = 0x1ED
derived_from = "nDeviceName0"

[Registers.nDeviceName3]
addr = 0x1EE
derived_from = "nDeviceName0"

[Registers.nDeviceName4]
addr = 0x1EF
derived_from = "nDeviceName0"
